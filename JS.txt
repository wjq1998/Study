转义字符：
\n	换行符,n代表new line
\\	斜杠
\'	单引号
\"	双引号
\t	tab缩进
\b	空格,b代表blank

隐式转换
    规则:
        +号两边只要有一个是字符串,都会把另一个转换为字符
        除了+以外的算术运算符- * / 等都会把数据转换为数字类型
    小技巧
        字符转数字：字符*1
        +号作为正号解析可以转换为Number
    
    转字符：对象+""

显示转换
    数字转换
        Number() 只能放数字类型的字符,不能放abc这样的数值,否贼会返回NaN
        parseInt() 将数据转换为整数,经常用于过过滤掉数字后面跟着的单位,比如10px(字符放数字前面好像不行,也会报NaN)
        parseFloat() 将数据转换为浮点数,经常用于过过滤掉数字后面跟着的单位,比如10px(字符放数字前面好像不行,也会报NaN)

    字符转换
        String(变量名或数字)
        变量名.toString(这里填转换为几进制)

自增运算符
    ++前置:先自增后运算
    ++后置:先运算后自增

等于和全等
    等于(==): 只要值一样就是true,不管数据类型
    等于(===): 值和数据类型必须都一样才是true

for循环跟while循环的区别
    如果明确了循环次数用for循环
    如果不明确循环次数用while循环

要回头看的:55，64，78，79，103-106 118-120
《学习JS看这个就够了，全面打通 JAVASCRIPT 知识点（更新到17章）》：12，13
NaN：不是数字
null：空对象(赋值了,但是内容为空)
undefined：没有赋值的变量

------------------------------------------
父节点查找(parentNode属性)
    返回最近一级的父节点,找不到返回null

子节点查找
    childNodes
        获得所有子节点,包括文本节点(空格,换行),注释节点
    children(重点)
        仅获得所有元素节点
        返回的值还是一个伪数组

兄弟节点查找
    下一个兄弟节点(nextElementSibling属性)
    上一个兄弟节点(previousElementSibling属性)

增加节点
    appendChild
        1.创建一个新的节点(如let li = document.createElement('li'))
        2.用指定的父元素.appendChild(要插入的元素)的方式将新节点放入指定元素的内部

    insertBefore
        父元素.insertBefore(要插入的元素,在哪个元素前面)

克隆节点
    cloneNode会克隆出一个跟原标签一样的元素,括号内传入布尔值
        若为true,则代表克隆时会包含后代节点一起克隆
        若为false,则代表克隆时不包含后代节点
        默认为false

删除节点
    在JS原生DOM操作中,要删除元素必须通过父元素删除
    语法:父元素.removeChild(要删除的元素)
    
------------------------------------------

盒模型：
	offsetParent:查找最近的进行过定位的父元素
	offsetWidth:水平方向 width + 左右padding + 左右border-width
	offsetTop:获取当前元素到 定位父节点 的top方向的距离
	--------------------------------------
	clientWidth:水平方向 width + 左右padding
	clientTop:上边框宽度
	获取当前页面宽度：
		console.log(document.document.Element.clientWidth);
	如果给元素设置display:none;客户端的client属性都为0
	尽量避免重复访问这些属性
	--------------------------------------
	scrollWidth:元素内容真实的宽度，包括溢出的部分，不包括边框
	scrollTop:元素被滚动的高度（可读写）
        获取页面的滚动距离:document.documentElement.scrollTop
	
	window.scrollTo(x坐标,y坐标);

DOM2级事件处理程序：
	addEventListener(事件名，回调函数，false（是否在捕获阶段触发回调函数））
	addEventListener() IE8不支持，IE attachEvent()

  阻止事件流动
    事件对象.stopPropagation()

  鼠标经过事件:
    mouseover和mouseout 都会有冒泡效果
    mouseenter和mouseleave 没有冒泡效果

  阻止默认行为,比如链接点击不跳转,表单域的不提交
    语法:事件对象.preventDefault
	
parseInt()：可以将一个字符串中的有效数字提取出来（碰到除数字外的内容终止提取）
parseFloat()：可以将一个字符串中的有效数字提取出来，适用于浮点数（碰到除数字外的内容终止提取）

JS中的变量都是保存到栈内存中的：
	基本数据类型直接保存在栈内存中存储
	值与值之间都是独立存在的，修改一个变量不会影响其他变量
	
	对象中的数据保存在堆内存中，每创建一个新的对象，就会在堆内存中开辟出一个新的空间
	而变量保存的是对象的内存地址（对象引用），如果两个变量保存的是同一个对象引用，当一个对象中的一个变量发生改变，另一个也会受到影响
	
在函数中，return后的语句都不会执行

全局作用域
	-直接编写在<script>标签中的JS代码，都在全局作用域中
	-全局作用域在页面打开时创建，在页面关闭时销毁
	-全局作用域中有一个全局对象window
		它代表一个浏览器的窗口，它由浏览器创建，我们可以直接使用
	-在全局作用域中：
		创建的所有变量都会作为window对象的属性保存

函数作用域：
	-调用函数时创建函数作用域，函数执行完毕以后，函数作用域销毁
	-每调用一次函数就会创建一个新的函数作用域，他们之间是互相独立的
	-在函数作用域中可以访问到全局作用域中的变量
	-在全局作用域中无法访问到函数作用域中的变量
	-在函数作用域中操作一个变量，它会先在自身的作用域中寻找，如果有就直接调用
		如果没有则向上一级作用域中寻找，直到找到全局作用域
		如果全局作用域中依然没有找到，则会报错
	-如果想要直接访问全局的变量，可以使用window.对象名
	-在函数作用域中也有声明提前的特性
		使用var关键字声明的变量，会在函数中所有代码执行之前被声明
	-在函数中，不使用var声明的变量都会变成全局变量
	
	
使用var关键字声明变量时，会在所有代码执行之前被声明，若不使用var，则变量声明不会被提前


函数的声明提前：
	-在函数声明形式创建的函数function 函数名(){}:它会在所有的执行代码执行之前就被创建，所以我们可以在函数声明之前调用函数
	-使用函数表达式创建的函数var 函数名=function(){}:不会被提前声明，所以不能在声明前调用
	
构造函数	
	-构造函数就是普通的函数，创建方式与普通函数没有区别，不同的是构造函数习惯首字母大写
	-普通函数是直接调用，构造函数需要使用new来调用
	-构造函数的执行流程
		1.创建一个新的对象
		2.将新建的对象设置为函数中的this，在函数中可以使用this来引用对象
		3.逐行执行函数中的代码
		4.将新建的对象作为返回值返回
	-使用同一个构造函数创建的对象，我们称为一类对象，也将一个构造函数称为一类，将通过一个构造函数创建的对象，称为是该类的实例
	
原型对象用来存储同类的公共数据，若与原型中的数据同名，则优先使用类中的。
	类访问原型：类名.prototype
	对象访问原型：对象名.__proto__
	用in来检查对象中是否有某个属性时，如果对象中没有，但原型中有，也返回true。格式：name(属性名) in mc(对象名)
	可以使用对象中的hasOwnProperty()来检查对象自身中是否含有某个属性（不包括原型）。格式：mc（对象名）.hasOwnProperty("age"(属性名))
------------------------------------------
查找字符串：
	-indexOf()/lastIndexOf():获取字符串中指定内容的索引值并返回索引值（第二个参数为开始的索引值，可省略）
	-search():获取字符串指定内容的索引（参数里一般为正则表达式）
	-includes():字符串中是否包含指定内容，返回true或false（第二个参数为开始的索引值，可省略）
	-startsWith():字符串是否以指定内容开头，返回true或false（第二个参数为开始的索引值，可省略）
	-endsWith():字符串是否以指定内容结尾，返回true或false（第二个参数为检索的长度，可省略）
获取指定位置的字符串：
	-charAt(index):返回字符串指定位置的字符
	-charCodeAt(index):返回字符串指定位置的Unicode编码
字符串截取：
	-slice(开始索引，结束索引):
	-substring(开始索引，结束索引):和上一个差不多，但不能接收负值，还会根据大小自动调整索引前后位置
	-substr(开始索引，截取长度):从字符串中截取指定的内容。不会修改原字符串，而是将截取到的内容返回
	-String.fromCharCode()：根据字符的 Unicode 编码获取字符
	-concat():字符串的连接,这种方法基本不用，直接把两个字符串相加就好
	-split():通过指定的分隔符，将一个字符串拆分成一个数组,不会改变原字符串
	-replace():将字符串中的指定内容，替换为新的内容并返回。不会修改原字符串。这个方法，默认只会替换第一个被匹配到的字符。如果要全局替换，需要使用正则
	-repeat():将字符串重复指定的次数。会返回新的值，不会修改原字符串
	-trim():去除字符串前后的空白
	-toLowerCase()/toUpperCase():大小写转换
	
------------------------------------------
数组的四个方法：
	-push():向数组的末尾添加一个或多个元素，并返回新的长度
	-pop():删除数组的最后一个元素，并将删除的元素作为返回值返回
	-unshift():向数组开头添加一个或多个元素，并返回新的长度
	-shift():删除数组的开头的第一个元素，并将删除的元素作为返回值返回
	
slice():
	-用来从数组中提取指定元素
	-该方法不会改变元素数组，而是将截取到的元素封装到一个新的数组中返回
	-参数
		1.截取开始的位置索引，包含开始索引
		2.截取结束的位置索引，不包含结束索引（可以省略不写，会截取从开始索引往后的所有元素）
	-索引可以传递一个负值，如果传递一个负值，则从后往前计算
		-1：倒数第一个
		-2：倒数第二个
		
splice():
	-可以用来删除数组中的指定元素
	-会影响到原数组，会将指定元素从原数组中删除，并将删除的元素作为返回值返回
	-参数：
		1.表示开始位置的索引
		2.表示删除的数量（可省略）
		3+.插入的新元素，这些元素会自动插入到开始位置索引前边（可省略）
		
concat():
	-用于连接两个或多个数组，将新的数组返回
	-该方法不会对原数组产生影响
	-用法：数组1.concat(数组2或元素)

join():
	-该方法可以将数组转换成一个字符串
	-该方法不会对原数组产生影响，而是将转换后的字符串作为结果返回
	-在join()中可以指定一个字符串作为参数，这个字符串将会成为数组中元素的连接符，如果不指定连接符，则默认使用逗号作为连接符
	
reverse():  
	-该方法用来反转数组（前边去后边，后边去前边）
	-该方法会修改原数组
	
sort():
	-可以用来对数组中的元素进行排序（按照Unicode编码）
	-会影响原数组

变量提升
	-指在代码执行前，会将带有var声明的语句提前声明，但不会赋值，但let不会提升
	
------------------------------------------
根据CSS选择器来获取DOM元素
    语法:
        document.querySelector('css选择器')
            参数:
                包含一个或多个CSS选择器"字符串"
            返回值:
                CSS选择器匹配的第一个元素,一个HTMLElement对象
                如果没有匹配到,返回null
        
        document.querySelectorAll('获取一个元素内的全部子元素')
            返回值:
                返回一个伪数组(无法push,pop等增删改的操作,需要遍历)

------------------------------------------
元素的innerText属性
    修改标签中的内容,只能识别内容,不能解析标签
元素的innerHTML属性
    修改标签中的内容,能够识别标签

如果纠结到底使用谁,可以直接选择innerHTML
------------------------------------------
设置/修改元素样式属性
    1.通过style属性操作CSS
        对象.style.样式属性=值
            1.修改样式通过style属性引出
            2.如果属性有-连接符,需要转换为小驼峰命名法
            3.赋值的时候,需要的时候不要忘记css单位,比如"px"
    2.通过类名(className)操作CSS
        语法:元素.className = 目标的CSS类名
        注意:
            1.由于class是关键字,所以使用className去代替
            2.className是使用新值换旧值,如果需要添加一个类,需要保留之前的类名
    3.通过classList操作类控制CSS
        为了解决className容易覆盖以前的类名,我们可以通过classList的方式追加和删除类名
            语法:
                元素.classList.add(类名) //添加一个类
                元素.classList.remove(类名) //删除一个类
                元素.classList.toggle(类名) //切换一个类(有目标的类就删除,没有就添加)
------------------------------------------
定时器-间歇函数
    
    开启定时器
        setInterval(函数,间隔时间(毫秒))
        返回值intervalID是一个非零数值,用来标识不同的定时器,以及后面关闭定时器
    关闭定时器
        clearInterval(开启定时器产生的变量名)

------------------------------------------
时间对象
    实例化(创建一个时间对象并获取当前时间)
        let date = new Date()
------------------------------------------
事件对象
  如何获取事件对象(一般命名为event,ev,e)
  元素.addEventListener('click',function(e){})
  
  常用属性
    type:获取当前的事件类型
    clientX/clientY:获取光标相对于浏览器可见窗口左上角的位置
    pageX/pageY:获取光标相当于浏览器整个文档坐标有关系
    offsetX/offsetY:获取光标相当于当前DOM元素左上角的位置
    key:用户按下的键盘值

  按键输入属性:keydown和keyup都可以
------------------------------------------
BOM是浏览器的对象模型
  延时函数
    setTimeOut(回调函数,等待的秒数)仅执行一次
    clearTimeOut(延时函数对象) 清除延时函数
  
  递归函数:就是自己调用自己
    function fn(){
      console.log(111)
      fn()
    }

  同步任务
    都在主线程上执行,形成一个执行栈
  异步任务
    一般都是通过回调函数来实现
    有三种类型
      1.普通事件,如:click,resize等
      2.资源加载,如:load,error等
      3.定时器,如setInterval,setTimeout等
      异步任务相关添加到任务队列中(任务队列也称消息队列)

  location 的数据类型是对象,他拆分并保存了URL地址的各个组成部分
    常用的属性和方法
      href 获取完整的URL地址,对其赋值时用于地址的跳转,赋值的网址必须是字符串
      search 获取地址中携带的参数,符号?后面的部分
      hash 获取地址中的哈希值,符号#后面的部分
      reload 用来刷新当前页面,传入参数true时表示强制刷新(强制刷新,不使用缓存,直接更新最新的内容拉到网上去)

------------------------------------------
本地存储(内部的值要用字符串)
  存储数据
    localStorage.setItem(key,value)
  获取数据
    localStorage.getItem(key)
  删除数据
    localStorage.removeItem(key)

  存储复杂数据类型 localStorage.setItem('obj',JSON.stringify(obj))
    本地只能存储字符串,无法存储复杂数据类型,需要将复杂数据类型转换为JSON字符串,再存储到本地
    JSON.stringify(复杂数据类型)
      将复杂数据转换为JSON字符串 存储本地存储中
    JSON.parse(JSON字符串)
      将JSON字符串转换为对象 取出时候使用
------------------------------------------
自定义属性
  程序员可以自己添加的属性,在DOM对象中找不到,无法使用语法节点操作,必须使用专门的API
    getAttribute('属性名') 获取自定义属性
    setAttribute('属性名','属性值') 设置自定义属性
    removeAttribute('属性名') 删除自定义属性

  data-自定义属性
    传统的自定义属性没有专门的定义规则,开发者随意定值,不够规范,所以在html5中推出了专门的data-自定义属性,在标签上一律以data-开头
    在DOM对象上一律以dataset对象获取
      直接使用dataset获取包含所有自定义属性的对象
      若dataset.属性名 则获取对应的自定义属性值
------------------------------------------
正则表达式
    创建方法
        使用构造函数创建正则表达式对象
            var 变量=new RegExp('正则表达式')
            var 变量=new RegExp('正则表达式','匹配模式')
        使用字面量创建正则表达式
            var 变量=/正则表达式/
            var 变量=/正则表达式/匹配模式
         “匹配模式”中可以填'i'（忽略大小写）或者'g'（全局匹配）
    
    可以使用test()方法，来判断指定字符是否符合规则
        正则表达式对象.test(str)
        返回ture或false
    
    避坑指南：全局匹配 g 慎用test()方法
        对于非全局匹配的正则表达式，test()只会检测是否存在某个目标字符串（只要存在就为 true），多次检测的结果都相同。例如：

            const reg = /test/;
            const str = '_test_test';

            reg.test(str) // true
            reg.test(str) // true
            reg.test(str) // true
        重点来了。
        当设置全局标志 /g 时，一旦字符串中还存在匹配，test() 方法都将返回 true，同时匹配成功后将把 lastIndex 属性的值设置为上次匹配成功结果之后的第一个字符所在的位置，下次匹配将从 lastIndex 指示的位置开始；匹配不成功时返回 false，同时将 lastIndex 属性的值重置为 0。
        举例：（很重要的例子，看仔细）

            const reg = /test/g;
            const str = '_test_test';

            console.log(reg.test(str)); // true
            console.log(reg.lastIndex); // 5

            console.log(reg.test(str)); // true
            console.log(reg.lastIndex); // 10

            console.log(reg.test(str)); // false
            console.log(reg.lastIndex); // 0
        总结：
            全局匹配模式g一般用于 exec()、match()、replace()等方法。
            全局匹配模式g如果用于test()方法会有问题。因为g模式会生成一个lastindex参数来存储匹配最后一次的位置。

    正则表达式简单语法
        检测一个字符中是否包含a或b
            /a|b/
            /[ab]/
        []的使用
            /[a-z]/：检查一个字符串那种是否包含任意小写字母
            /[A-Z]/：任意大写字母
            /[A-z]/：任意字母([a-Z])没用
            /[0-9]/：任意数字
            /a[bde]c/：检查一个字符串中是否包含 abc 或 adc 或 aec
        [^]：除了
            var reg = /[^ab]/; //规则：字符串中，除了a、b之外，还有没有其他的字符内容？
            var str = "acb";
            console.log(reg.test(str)); //打印结果：true
        支持正则的string对象的方法
            split()	
                将字符串拆分成数组	
            search()	
                搜索字符串中是否含有指定内容，返回索引index（只会找第一个，加了全局“g”都没用）	
            match()	
                根据正则表达式，从一个字符串中将符合条件的内容提取出来，放到数组中
            replace()	
                将字符串中的指定内容，替换为新的内容并返回
        正则表达式使用举例
            检查一个字符串是否是一个合法手机号
                手机号的规则：
                    以1开头（^1 表示1开头 , [^1]表示非1或除了1）
                    第二位是3~9之间任意数字
                    三位以后任意9位数字
                    正则实现：
                        var phoneStr = "13067890123";
                        var phoneReg = /^1[3-9][0-9]{9}$/;
                        console.log(phoneReg.test(phoneStr));
        正则表达式元字符
            .	查找任意字符，除了换行和行结束符
            \w	查找单词字符
            \W	查找非单词字符
            \d	查找数字
            \D	查找非数字字符
            \s	查找空白字符
            \S	查找非空白字符
            \b	匹配单词边界
            \B	匹配非单词边界
            \0	查找 NUL字符
            \n	查找换行符
            \f	查找换页符
            \r	查找回车符
            \t	查找制表符
            \v	查找垂直制表符
            \xxx	查找以八进制数 xxxx 规定的字符
            \xdd	查找以十六进制数 dd 规定的字符
            \uxxxx	查找以十六进制 xxxx规定的 Unicode 字符
        重复匹配
            在正则表达式语法中，定义了一组重复类量词，如表所示。它们定义了重复匹配字符的确数或约数。
            重复类量词列表
            n+	    匹配任何包含至少一个 n 的字符串
            n*	    匹配任何包含零个或多个 n 的字符串
            n?	    匹配任何包含零个或一个 n 的字符串
            n{x}	匹配包含 x 个 n 的序列的字符串
            n{x,y}	匹配包含最少 x 个、最多 y 个 n 的序列的字符串
            n{x,}	匹配包含至少 x 个 n 的序列的字符串

ECharts
    ECharts使用五部曲
        1.下载并引入ECharts.js文件
        2.准备一个具备大小的DOM容器
        3.初始化echarts实例对象
        4.指定配置项和数据
        5.将配置项设置给echarts实例对象

------------------------------------------
事件类型
    mouseenter 鼠标进入
    mouseleave 鼠标移出
    scroll 监听页面滚动
    resize 可视区域尺寸发生变化
    load 监听的页面资源加载完毕
    DOMContentLoaded 监听页面的DOM加载完毕