2.
    上网过程中，负责存放和对外提供资源的电脑，叫做服务器
    上网过程中，负责获取和消费资源的电脑，叫做客户端。

    URL地址的概念
        URL(全称是UniformResourceLocator)中文叫统一资源定位符，用于标识互联网上每个资源的唯一存放位置。
        浏览器只有通过URL地址，才能征确定位资源的存放位置，从而成功访问到对应的资源。
        URL地址一般由三部组成：
            ①客户端与服务器之间的通信协议
            ②存有该资源的服务器名称
            ③资源在服务器上具体的存放位置
            ①http://②www.cnblogs.com/③liulongbinblogs/p/11649393.html
3.
    如果要在网页中请求服务器上的数据资源，则需要用到XMLHttpRequest对象。
    XMLHttpRequest(简称hr)是浏览器提供的js成员，通过它，可以请求服务器上的数据资源。
    最简单的用法var xhrObji=new XMLHttpRequest()
    
    资源的请求方式
        客户端请求服务器时，请求的方式有很多种，最常见的两种请求方式分别为get和post请求。
            get请求通常用于获取服务端资源（向服务器要资源）
            例如：
            根据URL地址，从服务器获取HTML文件、Css文件、js文件、图片文件、数据资源等

            post请求通常用于向服务器提交数据（往服务器发送资源）
            例如：
            登录时向服务器提交的登录信息、注册时向服务器提交的注册信息、添加用户时向服务器提交的用户
            信息等各种数据提交操作
4.
    什么是Ajax
        Ajax的全称是Asynchronous Javascript And XML(异步JavaScript和XML).
        通俗的理解：在网页中利用XMLHttpRequest对象和服务器进行数据交互的方式，就是Ajax。
    为什么要学Ajax
        之前所学的技术，只能把网页做的更美观漂亮，或添加一些动画效果，但是，Ajx能让我们轻松实现网页与服务器之
        间的数据交互。
		
	可以在F12的Xhr中查看发起的请求详情
5.
    $.get()函数的语法
        jQuery中$.get()函数的功能弹一，专门用来发起get请求，从而将服务器上的资源请求到客户端来进行使用。
        $.get0函数的语法如下：
             $.get(url,[data],[callback])
                url:要请求的资源地址
                data:请求资源期间要携带的参数
                callback:请求成功的回调函数
6.
    $.post()函数的语法
        jQuery中$.post()函数的功能单一，专门用来发起post请求，从而向服务器提交数据。
        $.post()函数的语法如下：
            $.post(url,[data],[callback])
                url:提交数据的
                data:要提交的数据
                callback:数据成功时的回调函数
7.  
    $.ajax()函数的语法
        相比于$.get()和$.post()函数，jQuery中提供的$.ajax()函数，是一个功能比较综合的函数，它允许我们对
        Ajax请求进行更详细的配置。
        $.ajax()函数的基本语法如下：
            $.ajax({
            type:'',//请求的方式，例如GET或PoST
            url:'',//请求的URL地址
            data:{},//这次请求要携带的数据
            success:function(res){}//请求成功之后的回调函数
            })
8.
    使用Ajx请求数据时，被请求的URL地址，就叫做数据接口（简称接口）。同时，每个接口必须有请求方式，例如：
    http://www.liulongbin.top:3006/api/getbooks
    获取图书列表的接口(GET请求)
    http://www.liulongbin.top:3006/api/addbook
    添加图书的接口(PoST请求)
9.
    关于Postman的使用
	
	使用Postman测试POST接口
		1.选择请求的方式
		2.填写请求的URL地址
		3.选择Body面板并勾选数据格式
		4.填写发送到服务器的数据
		5.点击Send按钮发起POST请求
		6.查看服务器响应结果
10.
    什么是接口文档
        接口文档，顾名思义就是接口的说明文档，它是我们调用接口的依据。好的接口文档包含了对接口UL,参数以及输出内容的说明，我们参照接口文档就能方便的知道接口的作用，以及接口如何进行调用。
    2.接口文档的组成部分
        接口文档可以包含很多信息，也可以按需进行精简，不过，一个合格的接口文档，应该包含以下6项内容，从而为接口的调用提供依据：
            1.接口名称：用来标识各个接口的简单说明，如登录接口，获取图书列表接口等。
            2.接口URL:接口的调用地址。
            3.调用方式：接口的调用方式，如GET或POST.
            4.参数格式：接口需要传递的参数，每个参数必须包含参数名称、参数类型、是否必选、参数说明这项内容。
            5.响应格式：接口的返回值的详细描述，一般包含数据名称、数据类型、说明3项内容。
            6.返回示例（可选）：通过对象的形式，例举服务器返回数据的结构。
22.
    什么是表单
        表单在网页中主要负责数据采集功能。HTML中的<form>标签，就是用于采集用户输入的信息，并通过<form>标签的提交操作，把采集到的信息提交到服务器端进行处理。
    表单由三个基本部分组成：
        表单标签<form></form>
        表单域(包含了文本框、密码框、隐藏域、多行文本框、复选框、单选框、下拉选择框和文件上传框等)
        表单按钮
23.
    <form>标签属性
        action
            action属性用来规定当提交表单时，向何处发送表单数据。
            action属性的值应该是后端提供的一个URL地址，这个URL地址专门负责接收表单提交过来的数据。
            当<form>表单在未指定action属性值的情况下，action的默认值为当前页面的URL地址.也就是"当前页?表单内容"
            注意：当提交表单后，页面会立即跳转到action属性指定的URL地址
        target
            target属性用来规定在何处打开action URL.
            它的可选值有5个，默认情况下，target的值是_self,表示在相同的框架中打开action URL
                _blank
                    在新窗口中打开。
                _self
                    默认。在相同的框架中打开。
                _parent
                    在父框架集中打开。（很少用）
                _top
                    在整个窗口中打开。（很少用）
                framename
                    在指定的框架中打开。（很少用）
        method
            method属性用来规定以何种方式把表单数据提交到action URL.它的可选值有两个，分别是get和post.
            默认情况下，method的值为get,表示通过URL地址的形式，把表单数据提交到action URL.
            注意：
            get方式适合用来提交少量的、简单的数据。
            post方式适合用来提交大量的、复杂的、或包含文件上传的数据。
            在实际开发中，<form>表单的post提交方式用的最多，很少用gt。例如登录、注册、添加数据等表单操作，都需要
            使用post方式来提交表单。
        enctype
            用来规定在发送表单数据之前如何对数据进行编码。
            它的可选值有三个，默认情况下，enctype的值为application/x-www-form-urlencoded,表示在发送前编码所有的字符。
            application/x-www-form-urlencoded
                在发送前编码所有字符（默认）
            multipart/form-data
                不对字符编码。
                在使用包含文件上传控件的表单时，必须使用该值。
            text/plain
                空格转换为“+”加号，但不对特殊字符编码。（很少用）
            
            注意：
            在涉及到文件上传的操作时，必须将enctype的值设置为multipart/form-data
            如果表单的提交不涉及到文件上传操作，则直接将enctype的值设置为application/x-www-form-urlencoded即可
24.
    表单的同步提交
        通过点击submit按钮，触发表单提交的操作，从而使页面跳转到action URL的行为，叫做表单的同步提交。
    表单同步提交的缺点
        1.整个页面会发生跳转，跳转到action URL所指的地址，用户体验很差
        2.页面之前的数据会丢失
25.
    两种监听表单提交方式
        $('#form1').submit(function(){})
        $('#form1').on('submit',function(){})
        
    当监听到表单的提交事件以后，可以调用事件对象的event.preventDefault()函数，来阻止表单的提交和页面的跳转
        $('#f1').submit(function(e){
            alert('监听到了表单的提交事件')
            e.preventDefault()
        })


    serialize()函数
        为了简化表单中数据的获取操作，JQ提供了serialize()函数，其语法如下：
            $(selector).serialize();
        
        注意：在使用serialize()函数快速获取表单数据时，必须为每个表单元素添加name属性，如<input type = "text" name = "username">
        serialize()函数的好处：可以一次性获取到表单中所有的数据
29.
    模板引擎的好处
        减少了字符串的拼接操作
        使代码结构更清晰
        使代码更易于阅读与维护
    art-template是一个简约、超快的模板引擎

    art-template的使用步骤
        1.导入art-template
            <script scr='template-web.js'></script>
        2.定义数据
            var data={name:'zs'};
        3.定义模板
            <script type='text/html' id='tpl-user'>
                <h1>{{name}}</h1>
            </script>
        4.调用template函数
            var htmlStr=template('tpl-user'(指定模板的id),data);
        5.渲染HTML结构
            对象.html(htmlStr);
30.
    什么是art-template标准语法
        art-template提供了{{}}这种语法格式，在{{}}内可以进行变量输出，或循环数组等操作，这种{{}}语法在art-template中被称为标准语法

    在{{}}语法中，可以进行变量的输出、对像属性的输出、三元表达式输出、逻辑或输出、加减乘除等表达式输出

    标准语法-原文输出
        如果要输出的vlue值中，包含了HTML标签结构，则需要使用原文输出语法，才能保证HTML标签被正常渲染，如{{@ value}} //value的值为'<h3>文本内容</h3>'

    标准语法-条件输出
        如果要实现条件输出，则可以在{{}}中使用if..else if...if的方式，进行按需输出。
            {{if value}}按需输出的内容{{/if}}
            {{if v1}}按需输出的内容{{else if v2}}按需输出的内容{{/if}}
    
    标准语法-循环输出
        如果要实现循环输出，则可以在{{}}内，通过each语法循环数组，当前循环的索引使用$index进行访问，当前的循环项使用$value进行访问
            {{each arr}}
                {{$index}}{{$value}}
            {{/each}}
31.
    标准语法-过滤器
        {{value(这是过滤的数据) | filterName(这是过滤器的函数名)}}
    定义过滤器语法
        template.defaults.imports.filterName(过滤器名字，同上)=function(value){用return返回结果}
35.
    exec()函数用于检索字符串中的正则表达式的匹配
        如果字符串中有匹配的值，则返回该匹配值，否则返回null
        RegExpobject.exec(string)
    正则表达式分组
        正则表达式中（）包起来的内容表示一个分组，可以通过分组来提取自己想要的内容，示例代码如下：
            var str='<div>我是{{name}}</div>'
            var pattern =/({{[a-zA-2]+)}}/
            var patternResult=pattern.exec(str)
            console.log(patternResult)
            //得到name相关的分组信息
            //["{{name}}","name"(这里的内容就是上面用小括号提取的内容),index:7,input:"<div>{{name}}</div>",groups:undefined]
36.
    replace()函数
40.
    什么是XMLHttpRequest（差不多就是原生ajax）
        XMLHttpRequest(简称xhr)是浏览器提供的Javascript对象，通过它，可以请求服务器上的数据资源。
        之前所学的jQuery中的Ajax函数，就是基于xhr对象封装出来的。
41.
    使用xhr发起GET请求
        步骤：
            创建xhr对象
            调用xhr.open()函数
            调用xhr.send()函数
            监听xhr.onreadystatechange事件
        实例：
        //创建xhr对象
            var xhr=new XHLHttpRequest()
        //调用open函数
            xhr.open('GET',接口网址)
        //调用send函数
            xhr.send()
        //监听xhr.onreadystatechange事件
            xhr.onreadystatechange=function(
                //监听xhr对象的请求状readyState，与服务器响应状态status
                if(xhr.readyState===4 && xhr.status===200){
                    console.log(xhr.responseText)
                }
            )
    了解xhr对象的read小yState属性
        XMLHttpRequest对象的readyState属性，用来表示当前Ajax请求所处的状态。每个Ajax请求必然处于以下状态中的一个：
            0
                UNSENT
                    XMLHttpRequest对象已被创建，但尚未调用open方法。
            1
                OPENED
                    open()方法已经被调用。
            2
                HEADERS RECEIVED
                    send()方法已经被调用，响应头也已经被接收。
            3
                LOADING
                    数据接收中，此时response属性中已经包含部分数据。
            4
                DONE
                    Ajx请求完成，这意味着数据传输已经彻底完成或失败。
    使用xhr发起带参数的GET请求
        使用xhr对象发起带参数的GT请求时，只需在调用xhr.open期间，为URL地址指定参数即可：
            xhr.open ('GET','http://www.liulongbin.top:3006/api/getbooks?id=1')

        这种在URL地址问号后面拼接的参数，叫做查询字符串。

42.
    什么是查询字符串
        定义：查询字符串(URL参数)是指在URL的末尾加上用于向服务器发送信息的字符串（变量）。
        格式：将英文的？放在URL的末尾，然后再加上参数=值，想加上多个参数的话，使用&符号进行分隔。以这个形式，可以将想要发送给服务器的数据添加到URL中。
            //不带参数的RL地址
                http://www.liulongbin.top:3006/api/getbooks
            //带一个参数的URL地址
                http://www.liulongbin.top:3006/api/getbooks?id=1
            //带两个参数的URL地址
                http://www.liulongbin.top:3006/api/getbooks?id=1&bookname='西游记'

    GET请求携带参数的本质
        无论使用$.ajax(),还是使用$.get(),又或者直接使用xhr对象发起GET请求，当需要携带参数的时候，本质上，都是直接将参数以查询字符串的形式，追加到URL地址的后面，发送到服务器的。

43.
    什么是URL编码
        URL地址中，只允许出现英文相关的字母、标点符号、数字，因此，在UL地址中不允许出现中文字符。
        如果URL中需要包含中文这样的字符，则必须对中文字符进行编码（转义）。
        URL编码的原则：使用安全的字符（没有特殊用途或者特殊意义的可打印字符）去表示那些不安全的字符
        URL编码原则的通俗理解：使用英文字符去表示非英文字符。

    如何对URL进行编码与解码
        浏览器提供了URL编码与解码的API,分别是：
            encodeURI()编码的函数
            decodeURI()解码的函数

44.
    使用xhr发起POST请求
        步骤：
            创建xhr对像
            调用xhr.open()函数
            设置Content-Type属性（固定写法）
            调用xhr.send()函数，同时指定要发送的数据
            监听xhr.onreadystatechange事件
        示例：
            //1.创建xhr对象
                var xhr new XMLHttpRequest()
            //2.调用open（）
                xhr.open ('POST','http://www.liulongbin.top:3006/api/addbook')
            //3.设置Content-Type属性（固定写法）
                xhr.setRequestHeader ('Content-Type','application/x-www-form-urlencoded')
            //4.调用send（）,同时将数据以查询字符串的形式，提交给服务器
                xhr.send('bookname=水浒传&authora=施耐庵&publisher=天津图书出版社')
            /5.监听onreadystatechange事件
                xhr.onreadystatechange=function（）{
                    if (xhr.readystate ==4 &xhr.status ===200){
                    console.log(xhr.responseText)
                    }
                }
45.
    什么是数据交换格式
        数据交换格式，就是服务器端与客户端之间进行数据传输与交换的格式。
        前端领域，经常提及的两种数据交换格式分别是ML和JSON。其中XML用的非常少，所以，我们重点要学习的数据交换格式就是SON。

    什么是XML
        XML的英文全称是EXtensible Markup Language,即可扩展标i记语言。因此，XML和HTML类似，也是一种标记语言。

    XML和HTML的区别
        XML和HTML虽然都是标记语言，但是，它们两者之间没有任何的关系。
            HTML被设计用来描述网页上的内容，是网页内容的载体
            XML被设计用来传输和存储数据，是数据的载体

    XML的缺点
        XML格式臃肿，和数据无关的代码多，体积大，传输效率低
        在Javascript中解析XML比较麻烦

    什么是JSON
        概念：JSON的英文全称是JavaScript Object Notation,即"JavaScript对象表示法”。简单来讲，
        JSON就是Javascript对象和数组的字符串表示法，它使用文本表示一个S对象或数组的信息，因此，
        JSON的本质是字符串。
        作用：SON是一种轻量级的文本数据交换格式，在作用上类似于XML,专门用于存储和传输数据，但
        是SON比XML更小、更快、更易解析A
        现状：JSON是在2001年开始被推广和使用的数据格式，到现今为止，JSON已经成为了主流的数据交
        换格式。
46.
    JSON的两种结构
        JSON就是用字符串来表示Javascript的对象和数组。所以，JSON中包含对像和数组两种结构，通过这两种结构的相互嵌套，可以表示各种复杂的数据结构。
            对象结构：
                对象结构在SON中表示为{}括起来的内容。数据结构为{key:value,key:value,…}的键值对结构。
                其中，key必须是使用英文的双引号包裹的字符串，vlue的数据类型可以是数字、字符串、布尔值、nul、数组、对像6种类型。
            数组结构：
                数组结构在SON中表示为[]括起来的内容。数据结构为["java","javascript",30,true]
                数组中数据的类型可以是数字、字符串、布尔值、null、数组、对象6种类型。
    JSON语法的注意事项
        1.属性名必须使用双引号包裹
        2.字符串类型的值必须使用双引号包裹
        3.JSON中不允许使用单引号表示字符串
        4.JSON中不能写注释
        5.JSON的最外层必须是对像或数组格式
        6.不能使用undefined或函数作为SON的值

        JSON的作用：在计算机与网络之间存储和传输数据。
        JSON的本质：用字符串来表示Javascript对像象数据或数组数据

47.
    JSON和JS对象的关系
        JSON是JS对象的字符串表示法，它使用文本表示一个JS对像的信息，本质是一个字符串。

    JS0N和JS对象的互转
        要实现从JSON字符串转换为JS对象，使用JSON.parse()方法：
            var obj=JSON.parse ('{"a":"Hello","b":"World"}')
            //结果是{a:'Hello',b:World}
        要实现从JS对像转换为JSON字符串，使用JSON.stringify()方法：
            var json=JSON.stringify ({a:'Hello',b:'World'})
            //结果是'{"a":"Hello","b":"World")'
        序列化和反序列化
            把数据对象转换为字符串的过程，叫做序列化，例如：调用JSON.stringify()函数的操作，叫做JSON序列化。(变成数据叫做序列化)
            把字符串转换为数据对象的过程，叫做反序列化，例如：调用JSON.pars()函数的操作，叫做JSON反序列化。（变回对象叫做反序列化）
    
49.
    XMLHttpRequest Level2
        旧版XMLHttpRequest的缺点
            只支持文本数据的传输，无法用来读取和上传文件
            传送和接收数据时，没有进度信息，只能提示有没有完成

    XMLHttpRequest Level2的新功能
        可以设置HTTP请求的时限
        可以使用FormData对象管理表单数据
        可以上传文件
        可以获得数据传输的进度信息

    设置HTTP请求时限
        有时，AjX操作很耗时，而且无法预知要花多少时间。如果网速很慢，用户可能要等很久。新版本的XMLHttpRequest对象，增加了timeout属性，可以设置HTTP请求的时限：
            xhr.timeout =3000
        上面的语句，将最长等待时间设为3000毫秒。过了这个时限，就自动停止HTTP请求。与之配套的还有一个timeout事件，用来指定回调函数：
            xhr.ontimeout=function (){
                alert('请求超时！')
            }

50.
    FormData对象管理表单数据
        Ajax操作往往用来提交表单数据。为了方便表单处理，HTML5新增了一个FormData对像，可以模拟表单操作：
            //1.新建FormData对象
                var fd=new FormData()
            //2.为FormData添加表单项
                fd.append('uname','zs')
                fd.append('upwd','123456')
            //3.创建XHR对象
                var xhr=new XMLHttpRequest()
            //4.指定请求类型与URL地址
                 xhr.open('POST','http://www.liulongbin.top:3006/api/formdata')
            //5.直接提交FormData对象，这与提交网页表单的效果，完全一样
                xhr.send(fd)
    
    FormData对象也可以用来获取网页表单的值，示例代码如下：
        //获取表单元素
            var form=document.querySelector ('#forml')
        //监听表单元素的submit事件
            form.addEventListener ('submit',function(e){
                e.preventDefault()
                //根据form表单创建FormData对象，会自动将表单数据填充到FormData对象中
                var fd=new FormData(form)
                var xhr=new XMLHttpRequest()
                xhr.open(POST','http://www.liulongbin.top:3006/api/formdata')
                xhr.send(fd)
                xhr.onreadystatechange function（）{}
        })
51.
    上传文件
        新版MLHttpRequest对像，不仅可以发送文本信息，还可以上传文件。实现步骤：
            定义HTML结构
            验证是否选择了文件
            向FormData中追加文件
            使用xhr发起上传文件的请求
            监听onreadystatechange事件
53.
    显示文件上传进度
        新版本的XMLHttpRequest对象中，可以通过监听hr.upload.onprogress事件，来获取到文件的上传进度。语法格式如下：
            //创建HR对象
            var xhr=new XMLHttpRequest()
            //监听xhr.upload的onprogress事件
            xhr.upload.onprogress=function(e){
            //e:lengthComputable是一个布尔值，表示当前上传的资源是否具有可计算的长度
                if (e.lengthComputable){
                //e.loaded已传输的字节
                //e.total总共需传输的总字节
                var percentComplete=Math.ceil((e.loaded/e.total)*100)
                }
            }
54.
	使用jq验证文件是否选择
		$('button').on('click',function(){
			var files = $('#files1')[0].files	//加[0]是为了将jq对象转换为原生对象
			if(files.length<=0){
				return alert("请选择图片后上传")
			}
		})
		
		使用jq发起上传文件请求
		$.ajax({
            method:'Post',
            url:域名,
            data:fd,
            contentType:false,  //不修改Content-type属性,使用FormData默认的Content-Type值
            processData:false,  //不对FormData中的数据进行url编码,而是将FormData数据原样发送到服务器
            success:function(res){
                console.log(res)
            }
		})
	

    ajaxStart(callback)
        Ajax请求开始时，执行ajaxStart函数。可以在ajaxStart的callback中显示loading效果，示例代码如下：
            $(document).ajaxstart (function（）{
                $('#loading').show()    //显示加载动画
            })

    ajaxStop(callback)
        Ajax请求结束时，执行ajaxStop函数。可以在ajaxStop的callback中隐藏loading效果，示例代码如下：
            //自jQuery版本1.8起，该方法只能被附加到文档
            $(document).ajaxstop(function（）{
                $('#loading').hide()    //隐藏加载动画
            }

55.
    什么是axios
        Axios是专注于网络数据请求的库。
        相比于原生的XMLHttpRequest对象，axios简单易用。
        相比于jQuery,axios更加轻量化，只专注于网络数据请求。

    axios发起get请求的语法：
        axios.get('url',{params:{/*参数*/}}).then(callback)

        具体的请求示例如下：
        //请求的URL地址
        var url 'http://www.liulongbin.top:3006/api/get'
        //请求的参数对象
        var paramsobj={name:'zs',age: 20}
        //调用axios.get()发起GET请求
        axios.get(url,{params:paramsobj }).then(function(res){
            //res.data是服务器返回的数据
            var result=res.data
            console.log(res)
        )

    axios发起post请求的语法：
        axios.post('url',{参数}).then(callback)

        具体的请求示例如下：
        //请求的URL地址
        var url 'http://www.liulongbin.top:3006/api/post'
        //要提交到服务器的数据
        var dataobj={location:'北京'，address:'顺义'}
        //调用axios.post（）发起PoST请求
        axios.post(url,dataobj).then(function(res){
            //res,data是服务器返回的数据
            var result=res.data
            console.log(res)
        })

    axios也提供了类似于jQuery中$.ajax0的函数，语法如下：
        axios({
            method:'请求类型'，
            url:请求的URL地址'，
            data:{/*post数据*/}，
            params:{/get参数*/}
        }).then(callback)

56.
    同源
        如果两个页面的协议,域名和端口都相同,则两个页面具有相同的源

        如果域名后面没有端口号,则默认是80

    同源策略
        同源策略(英文全称 Same orgin policy)是浏览器提供的一个安全功能

        MDN官方给定的概念:同源策略限制了从一个源加载的文档或脚本如何与来自另一个源的资源进行交互.这是一个用于隔离潜在恶意文件的重要安全机制

        通俗的理解:浏览器规定,A网站的JS不允许与非同源的网站B之间进行资源交互,例如:
            1.无法读取非同源网站的Cookie,LocalStorage和IndexedDB        
            2.无法接触非同源网站的DOM
            3.无法向非同源网站地址发送Ajax请求

57.
    跨域
        同源是指两个URL的协议,域名,端口一致,反之,则是跨域
        
        出现跨域的根本原因:浏览器的同源策略不允许非同源的URL之间进行资源交互
        
        网页:http://www.test.com/index.html

        接口:http://www.api.com/userlist
    
    浏览器对跨域请求的拦截

        注意:浏览器允许发起跨域请求,但返回的数据会被浏览器的"同源策略拦截",无法被页面获取到

    如何实现跨域数据请求
        现如今,实现跨域数据请求,最主要的两种解决方案,分别是JSONP 和 CORS
        
        JSONP:出现的早,兼容性好(兼容低版本的IE).是前端程序员为了解决跨域问题,被迫想出的一种临时解决方案.缺点是支持GET请求,不支持POST请求

        CORS:出现的比较晚,它是W3C标准,属于跨域Ajax请求的根本解决方案.支持GET和POST请求.缺点是不兼容低版本的浏览器

58.
    JSONP的实现原理
        由于浏览器同源策略的限制,网页中无法通过Ajax请求非同源的接口数据.但是<script>标签不受浏览器同源策略的影响,可以通过src属性,请求非同源的js脚本

        因此,JSONP的实现原理,就是通过<script>标签的src属性,请求跨域的数据接口,并通过函数调用的形式,接收跨域接口响应回来的数据
        
        没搞懂,回头看

60.
    jQuery提供的$.ajax()函数，除了可以发起真正的Ajax数据请求之外，还能够发起SJONP数据请求，例如：
        $.ajax({
            url:'http://ajax.frontend.itheima.net:3006/api/jsonp?name=zs&age=20',
            //如果要使用$.ajax（）发起JSONP请求，必须指定datatype为jsonp
            dataType:'jsonp',
            success:function(res){
               console.log(res)
            }
        })
    默认情况下，使用jQuery发起SJONP请求，会自动携带一个callback=jQueryxxx的参数，jQueryxxx是随机生成的一个回调函数名称。

61.
    防抖策略是当事件触发后,延迟n秒后再执行回调,如果在这n秒内事件又被触发,则重新计时

    防抖的应用场景
        用户在输入框中连续输入一串字符时,可以通过防抖策略,只有输入完后,才执行查询的请求,这样可以有效减少请求的次数,节约请求资源
64.
    防抖大概意思就是延迟调用函数

65.
    节流策略(throttle)，顾名思义，可以减少一段时间内事件的触发频率。

    节流的应用场景
        1.鼠标连续不断地触发某事件,只在单位事件内触发一次
        2.懒加载时监听计算滚动条的位置,但不必每次滑动都触发,可以降低计算的频率,而不必去浪费CPU资源
66.
    节流阀的概念
        高铁卫生间是否被占用，由红绿灯控制，红灯表示被占用，绿灯表示可使用。
        假设每个人上卫生间都需要花费5分钟，则五分钟之内，被占用的卫生间无法被其他人使用。
        上一个人使用完毕后，需要将红灯重置为绿灯，表示下一个人可以使用卫生间。
        下一个人在上卫生间之前，需要先判断控制灯是否为绿色，来知晓能否上卫生间。

        节流阀为空，表示可以执行下次操作；不为空，表示不能执行下次操作。
        当前操作执行完，必须将节流阀重置为空，表示可以执行下次操作了。
        每次执行操作前，必须先判断节流阀是否为空。
70.
    通信，就是信息的传递和交换。
        通信三要素：
            通信的主体(收件人与寄件人)
            通信的内容
            通信的方式
    
    通信协议(Communication Protocol)）是指通信的双方完成通信所必须遵守的规则和约定。
        通俗的理解：通信双方采用约定好的格式来发送和接收消息，这种事先约定好的通信格式，就叫做通信协议。

    互联网中的通信协议
        客户端与服务器之间要实现网页内容的传输，则通信的双方必须遵守网页内容的传输协议。
        网页内容又叫做超文本，因此网页内容的传输协议又叫做超文本传输协议(HyperText Transfer Protocol),简称HTTP协议。
    
    HTTP协议采用了请求/响应的交互模型。

71.
    什么是HTTP请求消息
        由于HTTP协议属于客户端浏览器和服务器之间的通信协议。因此，客户端发起的请求叫做HTTP请求，客户
        端发送到服务器的消息，叫做HTTP请求消息。

        注意：HTTP清求消息又叫做HTTP请求报文。

    HTTP请求消息由请求行(request line)、请求头部(header)、空行和请求体4个部分组成。
        请求行由请求方式、URL和HTTP协议版本3个部分组成，他们之间使用空格隔开。

        请求头部用来描述客户端的基本信息，从而把客户端相关的信息告知服务器。比如：
            User-Agent用来说明当前是什么类型的浏览器；
            Content-Type用来描述发送到服务器的数据格式；
            Accept用来描述客户端能够接收什么类型的返回内容；
            Accept-Language用来描述客户端期望接收哪种人类语言的文本内容。
            
            请求头部由多行键/值对组成，每行的键和值之间用英文的冒号分隔。
        
        空行
            最后一个请求头字段的后面是一个空行，通知服务器请求头部至此结束。
            请求消息中的空行，用来分隔请求头部与请求体。

        请求体
            请求体中存放的，是要通过POST方式提交到服务器的数据。
            注意：只有POST请求才有请求体，GET请求没有请求体！

72.
    什么是HTTP响应消息
        响应消息就是服务器响应给客户端的消息内容，也叫作响应报文。

    HTTP响应消息的组成部分
        HTTP响应消息由状态行、响应头部、空行和响应体4个部分组成

        状态行
            状态行由HTTP协议版本、状态码和状态码的描述文本3个部分组成，他们之间使用空格隔开：

        响应头部
            响应头部用来描述服务器的基本信息。响应头部由多行键/值对组成，每行的键和值之间用英文的冒号分隔。

        空行
            在最后一个响应头部字段结束之后，会紧跟一个空行，用来通知客户端响应头部至此结束。
            响应消息中的空行，用来分隔响应头部与响应体。

        响应体
            响应体中存放的，是服务器响应给客户端的资源内容。

73.
    什么是HTTP请求方法
        HTTP请求方法，属于HTTP协议中的一部分，请求方法的作用是：用来表明要对服务器上的资源执行的操作。
        最常用的请求方法是GET和POST。
    
    GET
        （查询）发送请求来获得服务器上的资源，请求体中不会包含请求数据，请求数据放在协议头中。
    POST
        （新增）向服务器提交资源（例如提交表单或上传文件）。数据被包含在请求体中提交给服务器。
    PUT
        （修改）向服务器提交资源，并使用提交的新资源，替换掉服务器对应的旧资源。
    DELETE
        （删除）请求服务器删除指定的资源。

74.
    HTTP响应状态码
        HTTP响应状态码(HTTP Status Code),也属于HTTP协议的一部分，用来标识响应的状态。
        响应状态码会随着响应消息一起被发送至客户端浏览器，浏览器根据服务器返回的响应状态码，就能知道这次
        HTTP请求的结果是成功还是失败了。

    HTTP响应状态码的组成及分类
        HTTP状态码由三个十进制数字组成，第一个十进制数字定义了状态码的类型，后两个数字用来对状态码进行细分。

        HTTP状态码共分为5种类型：
            1**
                信息，服务器收到情求，需要请求者继续执行操作(实际开发中很少遇到1**类型的状态码)
            2**
                成功，操作被成功接收并处理
            3**
                重定向，需要进步的操作以完成请求
            4**
                客户端错误，请求包含语法错误或无法完成请求
            5**
                服务器错误，服务器在处理请求的过程中发生了错误
    
    2**成功相关的响应状态码
        2*范围的状态码，表示服务器已成功接收到情求并进行处理。常见的2*类型的状态码如下：
            200(OK)
                请求成功。一般用于GET与POST请求
            201(Created)
                已创建。成功请求并创建了新的资源，通常用于POST或PUT请求
        
    3*重定向相关的响应状态码    
        3*范围的状态码，表示表示服务器要求客户端重定向，需要客户端进一步的操作以完成资源的请求。常见的3*类型的状态码如下：
            301(Moved Permanently)
                永久移动。请求的资源已被永久的移动到新URL,返回信息会包括新的URL,浏览器会自动定向到新URL。今后任何新的请求都应使用新的URL代替
            302(Found)
                临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URL
            304(Not Modified)
                未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源（响应消息中不包含响应体）。客户端通常会缓存访问过的资源。

    4**客户端错误相关的响应状态码
        4**范围的状态码，表示客户端的请求有非法内容，从而导致这次请求失败。常见的4**类型的状态码如下：
            400(Bad Request)
                1、语义有误，当前请求无法被服务器理解。除非进行修改，否则客户端不应该重复提交这个请求。
                2、请求参数有误。
            401(Unauthorized)
                当前请求需要用户验证。
            403(Forbidden)
                服务器已经理解请求，但是拒绝执行它。
            404(Not Found)
                服务器无法根据客户端的请求找到资源（网页）
            408(Request Timeout)
                请求超时。服务器等待客户端发送的请求时间过长，超时。
    
    5**服务端错误相关的响应状态码
        5**范围的状态码，表示服务器未能正常处理客户端的请求而出现意外错误。常见的5**类型的状态码如下：
            500(Internal Server Error)
                服务器内部错误，无法完成请求。
            501(Not Implemented)
                服务器不支持该请求方法，无法完成请求。只有GET和HEAD请求方法是
                要求每个服务器必须支持的，其它请求方法在不支持的服务器上会返回501
            503(Service Unavailable)
                由于超载或系统维护，服务器暂时的无法处理客户端的请求。
        
76.
    版本控制软件
        概念：版本控制软件是一个用来记录文件变化，以便将来查阅特定版本修订情况的系统，因此有时也叫做“版本控制系统”。
        通俗的理解：把手工管理文件版本的方式，改为由软件管理文件的版本；这个负责管理文件版本的软件，叫做“版本控制软件”。

    版本控制软件的好处
        操作简便
            只需识记几组简单的终端命令，即可快速上手常见的版本控制软件
        易于对比
            基于版本控制软件提供的功能，能够方便地，比较文件的变化细节，从
            而查找出导致问题的原因
        易于回溯
            可以将选定的文件回溯到之前的状态，甚至将整个项目都回退到过去某
            个时间点的状态
        不易丢失
            在版本控制软件中，被用户误删除的文件，可以轻松的恢复回来
        协作方便
            基于版本控制软件提供的分支功能，可以轻松实现多人协作开发时的代
            码合并操作

    版本控制系统的分类
        本地版本控制系统
            单机运行，使维护文件版本操作工具化
        集中化的版本控制系统
            联网运行，支持多人协作开发；性能差、用户体验差
        分布式版本控制系统
            联网运行，支持多人协作开发；性能优秀、用户体验好

    本地版本控制系统
        特点：
            使用软件来记录文件的不同版本，提高了工作效率，
            降低了手动维护版本的出错率
        缺点：
        1.单机运行，不支持多人协作开发
        2.版本数据库故障后，所有历史更新记录会丢失
    
    集中化的版本控制系统（典型代表：SVN）
        特点：基于服务器、客户端的运行模式
            1.服务器保存文件的所有更新记录
            2.客户端只保留最新的文件版本
        优点：
            联网运行，支持多人协作开发
        缺点：
            1.不支持离线提交版本更新
            2.中心服务器崩溃后，所有人无法正常工作
            3.版本数据库故障后，所有历史更新记录会丢失

    分布式版本控制系统（典型代表Git）
        特点：基于服务器、客户端的运行模式
            服务器保存文件的所有更新版本
            客户端是服务器的完整备份，并不是只保留文件的最新版本
        优点：
            1.联网运行，支持多人协作开发
            2.客户端断网后支持离线本地提交版本更新
            3.服务器故障或损坏后，可使用任何一个客户端的备份进行恢复

77.
    Git之所以快速和高效，主要依赖于它的如下两个特性：
        1.直接记录快照，而非差异比较
        2.近乎所有操作都是本地执行

    SVN的差异比较
        传统的版本控制系统(例如SVN)是基于差异的版本控制，它们存储的是一组基本文件和每个文件随时间逐步累积的差异。

        好处：节省磁盘空间
        缺点：耗时、效率低
        在每次切换版本的时候，都需要在基本文件的基础上，应用每个差异，从而生成目标版本对应的文件。

    Git的记录快照
        Git快照是在原有文件版本的基础上重新生成一份新的文件，类似于备份。为了效率，如果文件没有修改，Git
        不再重新存储该文件，而是只保留一个链接指向之前存储的文件。

        缺点：占用磁盘空间较大
        优点：版本切换时非常快，因为每个版本都是完整的文件快照，切换版本时直接恢复目标版本的快照即可。
        特点：空间换时间

    Git近乎所有操作都是在本地执行
        在Git中的绝大多数操作都只需要访问本地文件和资源，一般不需要来自网络上其它计算机的信息。
            特性：
                断网后依旧可以在本地对项目进行版本管理
                联网后，把本地修改的记录同步到云端服务器即可

78.
     Git中的三个区域
        使用Gt管理的项目，拥有三个区域，分别是
            工作区（处理工作的区域）
            暂存区（已完成的工作的临时存放区域，等待被提交）
            Git仓库（最终的存放区域）                              

    Git中的三种状态
        已修改
            表示修改了文件，但还没将修改的结果放到暂存区
        已暂存
            表示对已修改文件的当前版本做了标记，使之包含在下次提交的列表中
        已提交 
            表示文件已经安全地保存在本地的Git仓库中

        注意：
            工作区的文件被修改了，但还没有放到暂存区，就是已修改状态。
            如果文件已修改并放入暂存区，就属于已暂存状态。
            如果Gt仓库中保存着特定版本的文件，就属于已提交状态。

    基本的Git的工作流程
        1.在工作区中修改文件
        2.将你想要下次提交的更改进行暂存
        3.提交更新，找到暂存区的文件，将快照永久性存储到Git仓库

79.
    配置用户信息
        git config --alobal user.name "用户名"
        git config --alobal user.email "用户邮箱"
    
    查看所有的全局配置项
        git config --list --global
    查看指定的全局配置项
        git config user.name
        git config user.email

    打开git帮助手册
        git help config
    想要获取git config命令的快速参考
        git config -h

80.
    获取git仓库的两种方式
        1.将尚未进行版本控制的本地目录转换为Gt仓库
        2.从其它服务器克隆一个已存在的Gt仓库
        以上两种方式都能够在自己的电脑上得到一个可用的Gt仓库

    在现有的目录中初始化仓库
        如果自己有一个尚未进行版本控制的项目目录，想要用Gt来控制它，需要执行如下两个步骤：
            1.在项目目录中，通过鼠标右键打开“Git Bash”
            2.执行git init命令将当前的目录转化为Git仓库
        git init命令会创建一个名为。git的隐藏目录，这个.git目录就是当前项目的Git仓库，里面包含了初始的必要文件，这些文件是Gt仓库的必要组成部分。

81.
    工作区文件的四种状态，分为两大类
        未被Git管理
            未跟踪(Untracked)
                不被Git所管理的文件

        已被Git管理
            未修改(Unmodified)
                工作区中文件的内容和Gt仓库中文件的内容保持一致
            已修改(Modified)
                工作区中文件的内容和Git仓库中文件的内容不一致
            已暂存(Staged)
                工作区中被修改的文件已被放到暂存区，准备将修改后的文件保存到Git仓库中

        Git操作的终极结果：让工作区的文件都处于“未修改”的状态

    检查文件状态
        可以使用git status命令查看文件处于什么状态

        使用git status输出的状态报告很详细，但有些繁琐。如果希望以精简的方式显示文件的状态，可以使用如下
        两条完全等价的命令，其中-s是-shot的简写形式，没有跟踪的文件前面是两个红色问号

82.
    使用命令git add开始跟踪一个文件，如：git add index.html

    清空窗口代码：clear

    提交更新
        现在暂存区中有一个index.html文件等待被提交到Git仓库中进行保存。可以执行git commit命令进行提交，
        其中-m选项后面是本次的提交消息，用来对提交的内容做进一步的描述,如：
            git commit -m "新建了一个index.html文件"

83.
    注意：修改过的、没有放入暂存区的文件前面有红色的M标记。

    暂存已修改的文件
        目前，工作区中的index.html文件已被修改，如果要暂存这次修改，需要再次运行git add命令，这个命令
        是个多功能的命令，主要有如下3个功效：
            ①可以用它开始跟踪新文件
            ②把已跟踪的、且已修改的文件放到暂存区
                已修改,未放进暂存区为红色
                未修改,已放进暂存区为绿色
            ③把有冲突的文件标记为已解决状态

    提交已暂存的文件
        再次运行git commit-m"提交消息"命令，即可将暂存区中记录的index.html的快照，提交到Git仓库中进行保存
        
84.
    撤销对文件的修改
        撤销对文件的修改指的是：把对工作区中对应文件的修改，还原成Gt仓库中所保存的版本。
        操作的结果：所有的修改会丢失，且无法恢复！危险性比较高，请慎重操作！
    
    撤销语法：git checkout -- index.html

85.
    向暂存区中一次性添加多个文件
        如果需要被暂存的文件个数比较多，可以使用如下的命令，一次性将所有的新增和修改过的文件加入暂存区，语法：
            git add .

            绿色M 表示修改后加入暂存区
            绿色A 表示新加入暂存区

        今后在项目开发中，会经常使用这个命令，将新增和修改过后的文件加入暂存区。
    
    如果需要从暂存区中移除对应的文件，可以使用如下的命令：
        git reset HEAD 要移除的文件名
        git reset HEAD .（移除所有文件）
    
    跳过使用暂存区域
        Git标准的工作流程是工作区→暂存区→Gt仓库，但有时候这么做略显繁琐，此时可以跳过暂存区，直接将
        工作区中的修改提交到Gt仓库，这时候Gt工作的流程简化为了工作区→Gt仓库。

        Git提供了一个跳过使用暂存区域的方式，只要在提交的时候，给git commit加上~a选项，Git就会自动把
        所有已经跟踪过的文件暂存起来一并提交，从而跳过git add步骤：
        git commit -a -m "描述消息"

86.
    移除文件
        从Git仓库中移除文件的方式有两种：
            ①从Git仓库和工作区中同时移除对应的文件
            ②只从Git仓库中移除指定的文件，但保留工作区中对应的文件

        #从Git仓库和工作区中同时移除index.js文件
            git rm -f index.js
        #只从Git仓库中移除index.css,但保留工作区中的index.css文件
            git rm --cached index.css

87.
    忽略文件
        一般我们总会有些文件无需纳入Gt的管理，也不希望它们总出现在未跟踪文件列表。在这种情况下，我们可以创建一个名为.gitignore的配置文件，列出要忽略的文件的匹配模式。
        文件.gitignore的格式规范如下：
            ①以#开头的是注释
            ②以/结尾的是目录
            ③以/开头防止递归
            ④以!开头表示取反
            ⑤可以使用glob模式进行文件和文件夹的匹配(glob指简化了的正则表达式)
    
    glob模式
        所谓的glob模式是指简化了的正则表达式：
        ①星号*匹配零个或多个任意字符
        ②[abc]匹配任何一个列在方括号中的字符(此案例匹配一个a或匹配一个b或匹配一个c)
        ③问号？只匹配一个任意字符
        ④在方括号中使用短划线分隔两个字符，表示所有在这两个字符范围内的都可以匹配（比如[0-9]表示匹配所有0到9的数字）
        ⑤两个星号*表示匹配任意中间目录(比如a/*/z可以匹配a/z、a/b/z或a/b/c/z等)
        ⑥若以/开头，则表示不递归（当前目录）
        ⑦若以/结尾，则表示文件夹

        #忽略所有的.a文件
            *a
        
        #但跟踪所有的lib.a文件,即使你在前面忽略了.a文件
            !lib.a

        #只忽略当前目录下的TODO文件,而不忽略subdir/TODO
            /TODO

        #忽略任何目录下名为build的文件夹
            build/

        #忽略doc/notes.txt 但不忽略doc/server/arch.txt
            doc/*.txt

        #忽略doc/目录及其所有子目录下的.pdf文件
            doc/**/*.pdf

88.
    查看提交历史
        如果希望回顾项目的提交历史，可以使用git log这个简单且有效的命令。
            #按时间先后顺序列出所有的提交历史，最近的提交排在最上面
                git log(后面出现冒号表示提交的历史有很多,按回车可以查看更多的历史,看q退出历史查看)
            #只展示最新的两条提交历史，数字可以按需进行填写
                git log -2
            #在一行上展示最近两条提交历史的信息
                git log -2 --pretty=oneline
            #在一行上展示最近两条提交历史的信息，并自定义输出的格式
            #h提交的简写哈希值%an作者名字   %a作者修订日期，按多久以前的方式显示    %s提交说明
            git log -2 --pretty=format:"%h | %an | %ar | %s"
    
    回退到指定版本
        #在一行上展示所有的提交历史
            git log --pretty=oneline
        #使用git reset--hard命令，根据指定的提交ID回退到指定版本
            git reset --hard 版本唯一标识符
        在I旧版本中使用git reflog--pretty=oneline命令，查看命令操作的历史
            git reflog --pretty=oneline
        #再次根据最新的提交ID,跳转到最新的版本
            git reset --hard 版本唯一标识符

89.
    Git小结
        ①初始化Gt仓库的命令
            git init
        ②查看文件状态的命令
            git status或git status -s
        ③一次性将文件加入暂存区的命令
            git add .
        ⑤将暂存区的文件提交到Gt仓库的命令
            git commit -m "提交消息内容"

90.
    什么是开源
        开源
            概念：即开放源代码
            基本含义：代码是公开的
            特点：任何人都可以去查看，修改和使用开源代码
        闭源
            概念：软件的代码是封闭的
            基本含义：只有作者能看到闭源软件的代码
            特点：只有作者能对源代码进行修改

    开源许可协议
        1.BSD
        2.Apache Licence 2.0
        3.GPL
            具有传染性的一种开源协议，不允许修改后和衍生的代码作为闭源的商业软件发布和销售
            使用GPL的最著名的软件项目是：Linux
        4.LGPL
        5.MIT
            是目前限制最少的协议，唯一的条件：在修改后的代码或者发行包中，必须包含原作者的许可信息
            使用MIT的软件项目有：jquery、Node.js

    为什么要拥抱开源
        开源的思想是“我为人人，人人为我”，人们越来越喜欢开源大致出于以下三个原因
            1.开源给使用者更多的控制权
            2.开源让学习变得容易
            3.开源才有真正的安全
        
        开源是软件开发领域的趋势，拥抱开源就像是站在巨人的肩膀上，不用自己重复造轮子，让开发越来越容易

    开源项目托管平台
        专门用于免费存放开源项目源代码的网站，叫做开源项目托管平台。目前世界上比较出名的开源项目托管平台主要有以下三个
            Github（全球最牛的开源项目托管平台，没有之一）
            Gitlab（对代码私有性支持较好，因此企业用户较多）
            Gitee（又叫做码云，是国产开源项目托管平台。访问速度快、纯中文界面、使用友好）

        注意：以上三个开源项目托管平台，只能托管以Git管理的项目代码，因此，它们的名字都以Git开头

    什么是Github
            Github是全球最大的开源项目托管平台。因为只支持Git作为唯一的版本控制工具，故名GitHub.
            在Github中，你可以：
                ①关注自己喜欢的开源项目，为其点赞打call
                ②为自己喜欢的开源项目做贡献(Pull Request)
                ③和开源项目的作者讨论Bug和提需求(Issues)
                ④把喜欢的项目复制一份作为自己的项目进行修改(Fok)
                ⑤创建属于自己的开源项目
                ⑥etc...

            所以,Github≠Git

91.
    Github HTTPS的使用

92.
    git push将本地仓库的内容更新到github服务器

93.
    SSH key
        SSH key的作用：实现本地仓库和Github之间免登录的加密数据传输。
        SSH key的好处：免登录身份认证、数据加密传输。
        SSH key由两部分组成，分别是：
            ①id rsa(私钥文件，存放于客户端的电脑中即可)
            ②id rsa.pub(公钥文件，需要配置到Github中)

    生成SSH key
        ①打开Git Bash
        ②粘贴如下的命令，并将your_email@example.com替换为注册Github账号时填写的邮箱：
            ssh-keygen -t rsa -b 4096 -C "your_email@example.com"
        ③连续敲击3次回车，即可在C:\Users\用户名文件夹\.ssh目录中生成idra和id rsa.pub两个文件

    配置SSH key
        ①使用记事本打开id rsa.pub文件，复制里面的文本内容
        ②在浏览器中登录Github,点击头像->Settings->SSH and GPG Keys->New SSH key
        ③将id rsa.pub文件中的内容，粘贴到Key对应的文本框中
        ④在Title文本框中任意填写一个名称，来标识这个Key从何而来

    检测Github的SSH key是否配置成功
        打开Git Bash,输入如下的命令并回车执行：
            ssh -T git@github.com

    将远程仓库克隆到本地
        打开Git Bash，输入如下的命令并回车执行
            git clone 远程仓库地址


94.
    分支在实际开发中的作用
        在进行多人协作开发的时候，为了防止互相干扰，提高协同开发的体验，建议每个开发者都基于分支进行项目功能的开发

    master主分支
        在初始化本地Git仓库的时候，Git默认已经帮我们创建了一个名字叫做master的分支。通常我们把这个master分支叫做主分支。

    功能分支
        由于程序员不能直接在master分支上进行功能的开发，所以就有了功能分支的概念。
        功能分支指的是专门用来开发新功能的分支，它是临时从master主分支上分叉出来的，当新功能开发且测试
        完毕后，最终需要合并到master主分支上

95.
    查看分支列表
        git branch
        注意：分支名字前面的*号表示当前所处的分支

    创建新分支
        git branch 分支名字（此时，新分支中的代码和当前分支完全一样）

    切换分支
        git checkout 分支名字
        
96.
    分支的快速创建与切换
        使用如下的命令，可以创建指定名称的新分支，并立即切换到新分支上：
            #-b表示创建一个新分支
            #checkout表示切换到刚才新建的分支上
            git checkout -b 分支名称
    
97.
    合并分支
        功能分支的代码开发测试完毕之后，可以使用如下的命令，将完成后的代码合并到master主分支上：
            #1.切换到master分支
            git checkout master
            #2.在master分支上运行git merge命令，将login分支的代码合并到master分支
            git merge login
    
    删除分支
        当把功能分支的代码合并到master主分支上以后，就可以使用如下的命令，删除对应的功能分支：
            git branch -d 分支名称(不要在当前分支删除当前分支,删不掉)

98.
    遇到冲突时的分支合并
        如果在两个不同的分支中，对同一个文件进行了不同的修改，Git就没法干净的合并它们。此时，我们需要打开
        这些包含冲突的文件然后手动解决冲突。

        手动解决冲突后,再执行如下的命令
            git add .
            git commit -m 说明内容

99.
    将本地分支推送到远程仓库
        如果是第一次将本地分支推送到远程仓库，需要运行以下命令
            #-u表示把本地分支和远程分支进行关联，只在第一次推送的时候需要带-山参数
                git push -u 远程仓库的别名 本地分支名称:远程分支名称
            #实际案例：
                git push -u origin payment:pay
            #如果希望远程分支的名称和本地分支名称保持一致，可以对命令进行简化：
                git push -u origin payment

    查看远程仓库中所有分支列表
        通过如下的命令，可以查看远程仓库中，所有的分支列表的信息：
            git remote show origin(远程仓库名称)
    
100.
    跟踪分支
        跟踪分支指的是：从远程仓库中，把远程分支下载到本地仓库中。需要运行的命令如下：
            #从远程仓库中，把对应的远程分支下载到本地仓库，保持本地分支和远程分支名称相同
                git checkout 远程分支的名称
            #示例：
                git checkout pay
            #从远程仓库中，把对应的远程分支下载到本地仓库，并把下载的本地分支进行重命名
                git checkout -b 本地分支名称 远程仓库名称/远程分支名称
            #示例：
                git checkout -b payment origin/pay
    
    拉取远程分支的最新的代码
        可以使用如下的命令，把远程分支最新的代码下载到本地对应的分支中：
            #从远程仓库，拉取当前分支最新的代码，保持当前分支的代码和远程分支代码一致
                git pull

    删除远程分支
        可以使用如下的命令，删除远程仓库中指定的分支：
            #刷除远程仓库中，指定名称的远程分支
                git push 远程仓库名称 --delete 远程分支名称
            #示例：
                git push origin --delete pay

101.
    总结
    ①能够掌握Gt中基本命令的使用
        git init（创建git仓库）
        git add .（将文件加入到暂存区）
        git commit -m "提交消息"（在本地进行版本提交）
        git status 或 git status -s（检查文件状态）
    ②能够使用Github创建和维护远程仓库
        能够配置Github的SSH访问
        能够将本地仓库上传到Github
    ③能够掌握Git分支的基本使用
        git checkout -b 新分支名称（创建新的分支，并快速切换到这个分支）
        git push -u origin 新分支名称（第一次将分支发送到github上，否则git push）
        git checkout 分支名称（切换当前所处分支）
        git branch（列出当前项目的分支）