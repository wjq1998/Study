5.什么是webpack
    web是前端项目工程化的具体解决方案
	提供了友好的前端模块化开发支持，以及代码压缩混淆、处理浏览器端JavaScript的兼容性、性能优化等强大的功能
    
    好处：让程序员把工作的重心放到具体功能的实现上，提高了前端开发效率和项目的可维护性。
    注意：目前Vue,React等前端项目，基本上都是基于webpack进行工程化开发的。
6.
	1.新建空白目录（不能有中文），并在路径输入cmd，在cmd中输入npm init -y，即刻在当前文件夹创建package.json文件
	2.新建src源代码目录
	3.新建src->index.html 首页和src->index.js脚本文件
	4.初始化首页的基本结构
	5.运行npm install jquery -S命令，安装jQuery（S用于明确告诉npm，包安装完成之后要将包的名字对应的版本号记录到package.json中的dependencies节点下，可以省略）
	6.通过ES6模块化方式导入jQuery，实现列表隔行变色效果

7.
    一直用到的包要放到dependencies节点,后期要删掉的包放在devDependencies节点
    
    在项目中安装webpack
        在终端运行如下的命令，安装webpack相关的两个包：
        npm install webpack@5.42.1 webpack-cli@4.7.2 --save-dev
        -S是-save的简写
        -D是-save-dev的简写

    在项目中配置webpack
        ①在项目根目录中，创建名为webpack.config.js的webpack配置文件，并初始化如下的基本配置：
            module.exports={
                mode:'development' //mode用来指定构建模式，可选值有development（开发）和production（上线）
            }
        ②在package.json的scripts节点下，新增dev脚本如下：
            "script":{
                "dev":"webpack"
            }
        ③在终端中运行npm run dev命令，启动webpack进行项目的打包构建

8.
    压缩代码
        将webpack.config.js的module.exports的mode改成production
    结论：
        开发的时候一定要用developemnt，因为追求打包速度，而不是体积
        发过来，发布上线的时候一定要用production，因为上线追求体积小，而不是打包速度

9.
    webpack.config,js文件的作用
        webpack.config,js是webpack的配置文件。webpack在真正开始打包构建之前，会先读取这个配置文件，
        从而基于给定的配置，对项目进行打包。
        注意：由于webpack是基于node.js开发出来的打包工具，因此在它的配置文件中，支持使用node.js相关
        的语法和模块进行webpack的个性化配置。

    webpack中的默认约定
        在webpack4.X和5.X的版本中，有如下的默认约定：
        ①默认的打包入口文件为src->index.js
        ② 默认的输出文件路径为dist->main.js
        注意：可以在webpack.config.js中修改打包的默认约定

    自定义打包的入口与出口
        在webpack.config.js配置文件中，通过entry节点指定打包的入口。通过output节点指定打包的出口。
        示例代码如下：
            const path=require("path");
            module.exports={
                mode:'development';
                entry:path.join(__dirname,路径)；
                output:{
                    path:path.join(__dirname,路径)， //输出文件的存放路径
                    filename:"wang.js" //输出文件名
                }

10.
    通过安装和配置第三方的插件，可以拓展webpack的能力，从而让webpack用起来更方便。最常用的
        webpack插件有如下两个：
        ①webpack-dev-server
            类似于node.js阶段用到的nodemon工具
            每当修改了源代码，vebpack会自动进行项目的打包和构建
        ②html-webpack-plugin
            vebpack中的HTML插件（类似于一个模板引擎插件）
            可以通过此插件自定制index.html页面的内容

    配置webpack-dev-server
        ①修改packagejson->scripts中的dev命令如下：
        "scripts":{
            "dev":"webpack serve",//script节点下的脚本，可以通过npm run执行
        }
        ②再次运行npm run dev命令，重新进行项目的打包
        ③在浏览器中访问http://localhost:8080地址，查看自动打包效果
        注意：webpack-dev-server会启动一个实时打包的http服务器

11.
    webpack-dev-server打包的js文件存在内存在，根目录中被隐藏，要在html中使用/main.js调取

12.
    安装html-webpack-plugin 
        npm i html-webpack-plugin@5.3.2 -D

13.
    解惑html-webpack-plugin
        ①通过HTML插件复制到项目根目录中的index.html页面，也被放到了内存中
        ②HTML插件在生成的index.html页面，自动注入了打包的main.js文件

14.
    devServer节点
        在webpack.config.js配置文件中，可以通过devServer节点对webpack-dev-server插件进行更多的配置，
        示例代码如下：
        devServer:{
            open:true,//初次打包完成后，自动打开浏览器
            host:'127.0.0.1',//实时打包所使用的主机地址
            port:80,//实时打包所使用的端口号
        }
        注意：凡是修改了webpack.config,js配置文件，或修改了package.json配置文件，必须重启实时打包的服
        务器，否则最新的配置文件无法生效！

15.

18.
    打包处理样式表中与url路径相关的文件
        ①运行npm i url-loader@4.1.1 file-loader@6.2.0 -D命令
        ②在webpack.config.js的module->rules数组中，添加loader规则如下：
            module:{
                rules:{
                    {test:/\.jpg|png|gif$/,use:"url-loader?2229"}
                }
            }
        其中？之后的是loader的参数项：
            limit用来指定图片的大小，单位是字节(byte)
            只有<=limit大小的图片，才会被转为base64格式的图片

24.
    在开发阶段运行dev，在发布阶段运行build

25.
    打包发布后将js文件统一到js文件夹中
         
26.
    什么是Source Map
        Source Map就是一个信息文件，里面储存着位置信息。也就是说，Source Map文件中存储着压缩混淆后的代码，所对应的转换前的位置。
        有了它，出错的时候，除错工具将直接显示原始代码，而不是转换后的代码，能够极大的方便后期的调试。 

28.
    Source map只显示行数不暴露源码
        在生产环境下，如果只想定位报错的具体行数，且不想暴露源码。此时可以将devtool的值设置为
        nosources-source-map。
        
29.

33.
    什么是vue
        1.构建用户界面
            用vue往html页面中填充数据，非常的方便
        2.框架
            框架是一套现成的解决方案，程序员只能遵守框架的规范，去编写自己的业务功能！
            要学习Vue,就是在学习vue框架中规定的用法！
            vue的指令、组件(是对UI结构的复用)、路由、VueX、vue组件库
            只有把上面老师罗列的内容掌握以后，才有开发u项目的能力！
34.
    vue框架的特性，主要体现在如下两个方面
        1.数据驱动视图
        2.双向数据绑定

35.
    MVVM
        MVVM是vue实现数据驱动视图和双向数据绑定的核心原理。MVVM指的是Model、.View和ViewModel,
        它把每个HTML页面都拆分成了这三个部分
            Model表示当前页面渲染时所依赖的数据源。
            View表示当前页面所渲染的DOM结构。
            ViewModel表示vue的实例，它是MVVM的核心。
            
38.
    1.指令的概念
        指令(Directives)是vue为开发者提供的模板语法，用于辅助开发者渲染页面的基本结构。
        Vue中的指令按照不同的用途可以分为如下6大类：
            ①内容渲染指令
            ②属性绑定指令
            ③事件绑定指令
            ④双向绑定指令
            ⑤条件渲染指令
            ⑥列表渲染指令
    
    1.1内容渲染指令
        内容渲染指令用来辅助开发者渲染DOM元素的文本内容。常用的内容渲染指令有如下3个：
        v-text
        {{}}
        v-html

    v-text用法
        <p v-text="username"></p>
        之后会将data中的username数据渲染到p中，但是会覆盖掉p的内容

    {{}}（插值表达式）
        <p>{{username}}</p>
        之后会将data中的username数据渲染到p中。在实际开发中用的最多，只是内容的占位符，不会覆盖原来的内容

    v-html 
        v-text指令和插值表达式只能渲染纯文本内容。如果要把包含HTML标签的字符串渲染为页面的HTML元素，
        则需要用到v-html这个指令

39.
    vue中的el如果指定了一个有许多同名的元素，比如指定了div标签，则只会渲染第一个div标签的内容

40.
    属性绑定指令
        插值表达式不能用在属性节点，只能用在内容节点
        在vue中，可以用v-bind:指令，为元素的属性动态绑定值，用法：
            在属性前加上“v-bind:”，在属性值中写上数据中对应数据的键名
            v-bind:简写是英文的冒号:

41.
    在vue提供的模板渲染语法中，除了支持绑定简单的数据值之外，还支持Javascript表达式的运算，例如：
        {{number+1}}
        {{ok?"yes":"no"}}
        {{message.split('').reverse().join('')}}

42.
    vue提供了v-on事件绑定指令，用来辅助程序员为DOM元素绑定事件监听。语法格式如下：
        <h3>count的值为：{{count}}</h3>
        <button v-on:click="add"></button>
        new Vue({
            methods:{
                add:function(){
                    console.log("ok")
                }
                简写为：
                add(){
                    console.log("ok")
                }
            }
        })

44.
    若想用事件修改42中count的值，则需要：
        vue.count+=1，不过最好写成this.count+=1

45.
    在绑定事件处理函数的时候，可以使用()传递参数，如42中的：
        add(n){
            this.count+=1
        }

46.
    v-on可以简写为@，如：<button @click="add(1)"></button>
    注意：原生DOM对象有onclick、oninput、onkeyup等原生事件，替换为vue的事件绑定形式后，
        分别为：v-on:click、v-on:input、v-on:keyup

47.
    绑定事件并传参
        在使用v-on指令绑定事件时，可以使用()进行传参，代码如下：
            <h3>{{count}}</h3>
            <button @click="addNewCount(2)">+2</button>

            methods:{
                addNewCount(step){
                    this.count += step
                }
            }

    $event
        $event是vue提供的特殊变量，用来表示原生的事件参数对象event。$event可以解决事件参数对象event被覆盖的问题。用法如下：
            <h3>{{count}}</h3>
            <button @click="addNewCount(2 , $event)">+2</button>

            methods:{
                addNewCount(step , e){
                    const color=e.target.style.backgroundColor
                    this.count += step
                }
            }

48.
    让事件阻止默认行为
        在事件后面加上.prevent，如@click.prevent="add"
    阻止冒泡
        在事件后面加上.stop
    以捕获模式触发当前的事件处理函数（从外到内触发事件)
        .capture
    事件只触发一次
        .once
    只有在event.target是当前元素自身时触发事件处理函数（不能被其他元素冒泡到）
        .self
    
50.
    按键修饰符
        在监听键盘事件时，我们经常需要判断详细的按键。此时，可以为键盘相关的事件添加按键修饰符，例如：
            在按“enter”时调用“submit()函数”
                <input @keyup.enter="submit">
            在按“esc”时调用“clearInput()函数”
                <input @keyup.esc="clearInput">

51.
    双向数据绑定实例
        Vue提供了V-model双向数据绑定指令，用来辅助开发者在不操作DOM的前提下，快速获取表单的数据。

52.
    v-model指令的修饰符
        .number
            将用户输入的数据转换为数值型
        .trim
            自动过滤用户输入的首尾空白字符
        .lazy
            在“change”时更新而非“input”时更新（也就是不要实时更新数据）

53.
    条件渲染指令
        1.v-show的原理是：动态为元素添加或移除display:none样式，来实现元素的显示和隐藏
            如果要频繁的切换元素的显示状态，用V-show性能会更好
        2.v-if的原理是：每次动态创建或移除元素，实现元素的显示和隐藏
            如果刚进入页面的时候，某些元素默认不需要被展示，而且后期这个元素很可能也不需要被展示出来，此时Vf性能更好
        3.在实际开发中，绝大多数情况，不用考虑性能问题，直接使用v-if就好了！！！
    用法：
        <p v-if="flag">文本内容</p>
        flag=ture

54.
    v-else-if
        v-else-if指令，顾名思义，充当v-if的“else-if块”，可以连续使用：
            <div v-if="type==='A'">优秀</div>
            <div v-else-if="type==='B'">良好</div>
            <div v-else-if="type==='C'">一般</div>
            <div v-else>差</div>

55. 
    vue提供了v-for列表渲染指令，用来辅助开发者基于一个数组来循环渲染一个列表结构。V-for指令需要使
        用(item,index) in items形式的特殊语法，其中：
            items是待循环的数组
            item是被循环的每一项
            idnex是当前项的索引值
        语法：
            data{
                list:[
                    {id:1,name:"zs"},
                    {id:2,name:"ls"}
                ]
            }
            
            <ul>
                <li v-for="(item,index) in list">姓名是：{{item.name}}</li>
            </ul>

56.
    官方建议：只要用到了v-for指令，那么一定要绑定一个:key属性
    而且，尽量把id作为key的值，如<tr v-for="(item,index) in list" :key="item.id"></tr>
    官方对:key的值类型，是有要求的,必须是字符串或数字类型
    :key的值千万不能重复，否则会报错
    使用index的值当做key没有任何意义（因为index不具有唯一性）

65.
    过滤器
        过滤器(（Filters)是vue为开发者提供的功能，常用于文本的格式化。过滤器可以用在两个地方：插值表达式和v-bind属性绑定。
        过滤器应该被添加在JavaScript表达式的尾部，由“管道符”进行调用，示例代码如下：
            <!-·在双花括号中通过"管道符"调用capitalize过滤器，对message的值进行格式化-->
            <p>{{message | capitalize}}</p>（将message首字母改成大写）
            <!--在v-bind中通过“管道符"调用formatId过诚器，对rawId的值进行格式化-->
            <div v-bind:id="rawId formatId"></div>

        过滤器的注意点
            1.要定义到filters节点下，本质是一个函数
            2.在过滤器函数中，一定要有return值
            3.在过滤器的形参中，就可以获取到管道符前面待处理的那个值

66.
    私有过滤器和全局过滤器
        在filters节点下定义的过滤器，称为“私有过滤器”，因为它只能在当前vm实例所控制的el区域内使用。
        如果希望在多个Vue实例之间共享过滤器，则可以按照如下的格式定义全局过滤器：
            Vue.filter("capitalize",(str)=>{
                过滤器内部代码
            })
        如果全局过滤器和私有过滤器名字重复，此时按照“就近原则”，调用私有过滤器

68.
    过滤器可以串联地调用，例如{{message|filterA|filterB}}，当前面的第二个过滤器会将第一个过滤器的运算结果放进来继续运算
    过滤器的本质是函数，因此可以接受参数，格式如下：
        <p>{{message|filterA(arg1,arg2)}}</p>
        //在过滤器处理函数的形参列表中：
        //  第一个参数：永远都是“管道符”前面待处理的值
        //  第二个参数开始，才是调用过滤器时传递过来的arg1和arg2参数
        Vue.filter("filterA",(mes,arg1,arg2)=>{
            过滤器代码
        })

69.
    watch侦听器
        watch侦听器允许开发者监视数据的变化，从而针对数据的变化做特定的操作。
        语法格式如下：
            const vm=new Vue({
                el:"#app",
                data:{username:""},
                watch:{
                    //监听username值的变化
                    //newVal是变化后的新值,oldVal是变化前的旧值
                    username(newVal,oldVal){
                        console.log(newVal,oldVal)
                    }
                }
            })

71.
    侦听器格式
        方法格式侦听器（69的那种）
            缺点1：无法在刚进入页面的时候，自动触发
            缺点2：如果侦听的是一个对象，如果对象中的属性发生了变化，不会触发侦听器
        对象格式侦听器（下面那种）
            好处1：可以通过immediate选项，让侦听器自动触发
            好处2：可以通过deep选项，让侦听器深度监听对象中每个属性的变化，将deep属性改为true
                watch:{
                    username:{
                        handler:(newVal,oldVal)=>{
                            函数体
                        }
                    },
                    immediate:true  //immediate选项的默认值是false，immdiate的作用是：控制侦听器是否自动触发一次
                }

72.
    深度侦听
        在对象格式侦听器中加上deep:true

73.
    如果要侦听对象的子属性变化，则需要包裹一层引号
        "info.username"(newVal){
            函数体
        }

74.
    什么是计算属性
        计算属性指的是通过一系列运算之后，最终得到一个属性值。
        这个动态计算出来的属性值可以被模板结构或methods方法使用

75.
    计算属性
        特点：
            1.定义的时候，要被定义为“方法"
            2.在使用计算属性的时候，当普通的属性使用即可
        好处：
            1.实现了代码的复用
            2.只要计算属性中依赖的数据源变化了，则计算属性会自动重新求值！

    const vm=new Vue(){
        computed:{
            rgb(){
                return `rgb(${this.r},${this.g},${this.b})`
            }
        }
    }

76.
    axios
        是一个专注于网络请求的库

        语法：
            axios({
                method:"get",
                url:"域名"
            })then(function(book){
                console.log(book.data)
            })

77.
    get传参用params:{} 
    post传参用data:{}
    //如果调用某个方法的返回值是Promise实例，则前面可以添加await，这样会直接将Promise实例转化为内部的数据，然后再用解构赋值将里面data的数据拿出来
    //await只能用在被async“修饰”的方法中
    document.querySelector("#btnPost").addEventLister('click',async function(){
        await axios({
            函数体
        })
    })

78.
    解构赋值的时候，可以使用 : 来重命名，如：{data:res}
    
    1.调用axios之后，可以是用async/await进行简化
    2.使用解构赋值，从axios封装对象中，将data属性解构出来
    3.把解构的data属性，用冒号进行重命名，一般都重命名为{data:res}
    4.再将里面的数据打印出来console.log(res.data)，重命名之后就不会有data.data这种情况了

79.
    axios.get格式
        axios.get("url地址",{
            params:{}
        })

    axios.post格式
        axios.post("url地址",{})

80.
    单页面应用程序
        单页面应用程序(英文名：Single Page Application)简称SPA,顾名
        思义，指的是一个Web网站中只有唯一的一个HTML页面，所有的功能
        与交互都在这唯一
        
    什么是vue-cli
        vue-cli是Vue.js开发的标准工具。它简化了程序员基于webpack创建工程化的Vue项目的过程。
        引用自vue-cli官网上的一句话：
        程序员可以专注在撰写应用上，而不必花好几天去纠结webpack配置的问题。

    安装和使用
        vue-cli是npm上的一个全局包，使用npm install命令，即可方便的把它安装到自己的电脑上：
        npm install -g @vue/cli
		
81.
	创建vue的工程化项目
		vue create 项目名

84.
    vue项目中src目录的构成：
        assets文件夹：存放项目中用到的静态资源文件，例如：css样式表、图片资源
        components文件夹：程序员封装的、可复用的组件，都要放到components目录下
        main.js是项目的入口文件。整个项目的运行，要先执行main,js
        App.Vue是项目的根组件。
    
85.
    vue项目的运行流程
        在工程化的项目中，vue要做的事情很单纯：通过main.js把App.vue渲染到index.html的指定区域中。
        其中：
            ①App.Vue用来编写待渲染的模板结构
            ②index.html中需要预留一个el区域
            ③main,js把App.vue渲染到了index..html所预留的区域中

        比如：
            html文件
                <div id="app"></div>
            
            vue文件
                <template>
                    <div>
                        <p>one</p>
                        <p>one</p>
                    </div>
                </template>

            js文件
                import Vue from "vue"
                import App from "./App.vue"

                new Vue({
                    el:"#app"
                    render:h=>h(App)
                })
            
            最后html的div会替换成vue文件里div的内容

86.
    Vue实例的$mount()方法，作用与el属性完全一样，如下：
        new Vue({
            el:"#app"
            render:h=>h(App)
        })
        可以写成
        new Vue({
            render:h=>h(App)
        }).$mount("#app")

87.
    1.什么是组件化开发
        组件化开发指的是：根据封装的思想，把页面上可重用的U结构封装为组件，从而方便项目的开发和维护。

    2.Vue中的组件化开发
        Vue是一个支持组件化开发的前端框架。
        Vue中规定：组件的后缀名是.vue。之前接触到的App.vue文件本质上就是一个Vue的组件

    3.Vue组件的三个组成部分
        每个.Vue组件都由3部分构成，分别是：
            template->组件的模板结构
            script->组件的JavaScript行为
            style->组件的样式
        
        示例代码如下：
            <template>
                <div>
                    <p>one</p>
                </div>
            </template>

            <script>
                //默认输出，固定写法
                export default{
                    data(){
                        return{
                            username:"wang"
                        }
                    }
                }
            </script>

            <style>
                css样式
            </style>

88.
    <script>
                //默认输出，固定写法
                export default{
                    data(){
                        return{
                        }
                    },
                    methods:{},//当前组件的函数
                    watch:{},//当前组件的侦听器
                    computed:{},//当前组件的计算属性
                    filters:{}//当前组件的过滤器
                }
            </script>

89.
    在template中只能有一个根元素，也就是只能有一个div根元素


90.
    在webpack.config.js中定义路径中的@
    module.exports={
        resolve:{
            alias:{
                @:path.join(__dirname,"./src")
            }
        }
    }

    使用组件的三个步骤
        <div class="box">
            步骤3：以标签的形式使用刚才注册的组件
            <Left></Left>
        </div>
        <script>
            步骤1：使用import语法导入需要的组件
            inport Left form "@/components/Left.vue"

            步骤2：使用components节点注册组件
            export default{
                components:{
                    Left
                }
            }
        </script>
    
94.
    通过components注册的是私有子组件
        例如：
        在组件A的components节点下，注册了组件F
        则组件F只能用在组件A中；不能被用在组件C中

    注册全局组件
        在vue项目的main.js入口文件中，通过Vue.component()方法，可以注册全局组件。代码如下：
            //导入需要全局注册的组件
            import Count from 路径
            //参数1：字符串格式，表示组件的“注册名称”(也就是标签名)
            //参数2：需要被全局注册的那个组件
            Vue.component("MyCount",Count)

    安装Vetur组件后，在vue文件中输入“<”，然后回车，可以快速生成vue模板结构

96.
    组件的props（自定义属性）
        props是组件的自定义属性，在封装通用组件的时候，合理地使用props可以极大的提高组件的复用性！
        语法格式如下：
            export default{
                props:["自定义属性A","自定义属性B",...]
            }

97.
    在使用自定义属性的时候，可以在属性前面加上:使字符变成数字

98.
    props是只读的
        vue规定：组件中封装的自定义属性是只读的，程序员不能直接修改props的值。否则会报错。

    将props的值转存到data
        data(){
            return{
                count:this.init
            }
        }

99.
    props的默认值
        export default{
            props:{
                init:{
                    default:0 //如果外界使用该组件的时候，没有传递init属性，则默认生效该值
                }
            }
        }

100.
    props的值类型
        export default{
            props:{
                init:{
                    default:0 //如果外界使用该组件的时候，没有传递init属性，则默认生效该值
                    type:Number //init的值必须是Number数值类型，否则会报错
                }
            }
        }

101.
    props的required必填项
        export default{
            props:{
                init:{
                    default:0 //如果外界使用该组件的时候，没有传递init属性，则默认生效该值
                    type:Number //init的值必须是Number数值类型，否则会报错
                    required:true //当使用该组件时，若没有给init赋值，则报错
                }
            }
        }

102.
    组件之间的样式冲突问题
        默认情况下，写在。Vue组件中的样式会全局生效，因此很容易造成多个组件之间的样式冲突问题。
        导致组件之间样式冲突的根本原因是：
            ①单页面应用程序中，所有组件的DOM结构，都是基于唯一的index.html页面进行呈现的
            ②每个组件中的样式，都会影响整个index.html页面中的DOM元素

        解决方法：
            在组件内<style>标签中加上scoped
            原理：在当前组件的每个标签中加上一个同名属性，然后通过属性选择器来控制样式

103.
    scoped的缺点：无法操控当前组件子组件中的css样式
    如果需要修改，则要在修改的标签或id名前面加上/deep/，如：
        /deep/ h5
        结果便是[scoped生成的属性名] h5，相当于一个后代选择器

105.
    生命周期&生命周期函数
        生命周期(Life Cycle)是指一个组件从创建->运行->销毁的整个阶段，强调的是一个时间段。
        生命周期函数：是由VUe框架提供的内置函数，会伴随着组件的生命周期，自动按次序执行。

    组件创建阶段
        beforeCreate：组件刚开始创建
        Created：组件在内存中创建好
        beforeMount：将要渲染组件
        Mounted：组件已经渲染到页面
    组件运行阶段
        beforeUpdate
        updated
    组件销毁阶段
        beforeDestroy
        destroyed

107.

108.
    如果想要操作当前组件的DOM，最早，只能在mounted阶段执行

109.
    当数据改变时，触发beforeUpdate

    beforeUpdate，数据是最新的，DOM还是旧的，比如：
        修改了页面<p>{{message}}</p>中的内容
        则message中的数据发生了变化
        但如果用innerHTML提取p中的内容，还是旧的

    当数据发生变化之后，为了能操作到最新的DOM结构，必须将代码写到updated生命周期函数中
    
110.
    常用的三个生命周期函数
        1.Created
        2.Mounted
        3.updated

111.
    组件之间的关系
        在项目开发中，组件之间最常见的关系分为如下两种：
            1.父子关系
            2.兄弟关系

        父子组件之间的数据共享又分为：
            ①父->子共享数据
            ②子->父共享数据

        父组件向子组件共享数据需要使用自定义属性。示例代码如下：
            //父组件
            <Son :msg="message" :user="userinfo"></Son>
            
            data(){
                return{
                    message:"wang",
                    userinfo:{name:"zs",age:20}
                }
            }

            //子组件
            <template>
                <div>
                    <h5>Son组件</h5>
                    <p>父组件传过来的值是：{{msg}}</p>
                    <p>父组件传过来的user是：{{user}}</p>
                </div>
            </template>
            props:["msg","user"]

114.
    子组件向父组件共享数据使用自定义数据。示例代码如下：
        //子组件
        export default{
            data(){
                return {count:0},
                methods:{
                    add(){
                        this.count+=1
                        this.$('numchange',this.count)
                    }
                }
            }
        }

        //父组件
        <Son @numchange="getNewCount"></Son>
        export default{
            data(){
                return {
                    countFromSon:0
                }
            },
            methods:{
                getNewCount(val){
                    this.countFromSon=val
                }
            }
        }

115.
    兄弟组件之间的数据共享
        在vue2.x中，兄弟组件之间的数据共享方案是EventBus
    
116.
    EventBus的使用步骤
        ①创建eventBus.js模块，并向外共享一个Vue的实例对象，格式：
            import Vue from "vue"
            export default new Vue()
        ②在数据发送方，调用bus.$emit('事件名称'，要发送的数据)方法触发自定义事件
        ③在数据接收方，调用buS.$on('事件名称'，事件处理函数)方法注册一个自定义事件
    
118.
    ref
        什么是ref引用
            ref用来辅助开发者在不依赖于jQuery的情况下，获取DOM元素或组件的引用。
            每个Vue的组件实例上，都包含一个$refs对象，里面存储着对应的DOM元素或组件的引用。默认情况下，
            组件的$refs指向一个空对象。
        
        使用方法：
            1.在要控制的元素中加入属性ref="自己起个名字"
            2.用this.$refs.名字.style即刻更改其样式

        如果有ref同名的元素，则会拿到靠后的元素

119.
    使用ref引用组件实例
        如果想要使用rf引用页面上的组件实例，则可以按照如下的方式进行操作：
        //使用ref属性，为对应的“组件”添加引用名字
        <my-conter ref="counterRef"></my-conter>
        <button @click="g etRef">获取$refs引用</button>

        methods:{
            getRef(){
                //通过this.$refs引用对象，可以引用组件的实例
                console.log(this.$refs.counterRef)
                //引用到组件的实例之后，就可以调用组件上methods方法
                this.$refs.counterRef.add()
            }
        }

121.
    this.$nextTick(回调函数)
        等页面的DOM渲染完毕之后再调用回调函数中的内容

123.
    forEach循环一旦开始，就要从头循环到尾，用return或break都无法打断
        arr.forEach((item,index)=>{

        })
    但用some可以通过return true来终止循环
        arr.some((item,index)=>{

        })

124.
    every：用于判断是否每一项都达到了想要的效果
        arr.every(item=>item.state) //判断数组中的每一项中的state是否都为ture

125.
    数组的reduce方法（累加）
        语法：const result=arr.filter(item=>item.state).reduce((累加的结果，当前的循环项)=>{},初始值)，示例如下：

        const arr=[
            {id:1,name:"西瓜",state:true,price:10,count:1},
            {id:2,name:"榴莲",state:false,price:80,count:2},
            {id:3,name:"草莓",state:true,price:20,count:3},
        ]

        const result=arr.filter(item=>item.state).reduce((amt，item)=>{
            return amt+=item.price*item.count
        },0)

146.
    动态组件
        动态组件指的是动态切换组件的显示和隐藏

    如何实现动态组件渲染
        vue提供了一个内置的<component>组件，专门用来实现动态组件的渲染。示例代码如下：
            <component :is="comName"></component> //最终便会将Left组件渲染到页面上
            export default{
                data(){
                    comName:"Left"
                }
            }

148.
    keep-alive
        当组件因为component被切换隐藏之后，其连同内部的数据会被销毁，若想保留数据，则要使用keep-alive标签，用法如下：
            <keep-alive>
                <component :is="comName"></component>
            </keep-alive>
            //当切换组件时，原来的组件将被缓存，等待再次被激活
        
        keep-alive对应的生命周期函数
            当组件被缓存时，会自动触发组件的deactivated生命周期函数。
            当组件被激活时，会自动触发组件的activated生命周期函数
                当组件第一次创建的时候，既会执行created声明周期函数，也会执行activated生命周期函数
                当组件在缓存被激活的时候，只会触发activated生命周期，不再触发created。因为组件没有被重新创建
        
149.
    keep-alive的include属性
        include属性用来指定：只有名称匹配的组件会被缓存。多个组件名之间使用英文的逗号分隔：
            <keep-alive include="Left,Center">
                <component :is="comName"></component>
            </keep-alive>
    
    keep-alive的exclude属性
        与include效果相反，两者不能同时使用

150.
    如果在“声明组件（定义模板结构）”的时候，没有为组件指定name名称，则组件的名字默认就是“注册时候的名称”
        指定name属性：
            export default{
                name:"myLeft"
            }
    
    对比：
        1.组件的“注册名称”的主要应用场景是：以标签的形式，把注册好的组件，渲染和使用到面结构之中
        2.组件声明时候的“name”名称的主要应用场景：结合<keep-alive>:标签实现组件缓存功能以及在调试工具中看到组件的name名称以及vue调试工具

151.
    插槽
        插槽(Slot)是Vue为组件的封装者提供的能力。允许开发者在封装组件时，把不确定的、希望由用户指定的部分定义为插槽。
        讲人话就是开发完组件之后，有一块地方空着，要使用组件的用户自己放进html标签
        用法：
            //组件Left部分
            <template>
                <slot></slot>
            </template>
            //app部分
            <Left>
                <p>lala</p>
            </Left>
            渲染结果就是<p>lala</p>会替换掉Left组件中的<slot></slot>

152.
    vue官方规定，每个插槽都得有一个name属性，如：<slot name="default"></slot>
    如果省略了name属性，则有一个默认名称叫做default

    默认情况下，使用组件的时候，提供的内容都会被填充到name为default的插槽之中

    <!-1.如果要把内容填充到指定名称的插槽中，需要使用v-slot：这个指令->
    <!-2.v-slot:后面要跟上插槽的名字->
    <!-3.v-slot：指令不能直接用在元素身上，必须用在template标签上->
    <!-4 template这个标签，它是一个虚拟的标签，只起到包裹性质的作用->
        <Left>
            <template v-slot:default>
                <p></p>
            </template>
        </Left>

153.
    v-slot的简写形式是井号“#”

    插槽的后备内容（默认内容）
        封装组件时，可以为预留的<slot>插槽提供后备内容（默认内容）。如果组件的使用者没有为插槽提供任何内容，则后备内容会生效。示例代码如下：
            <template>
                <p>lalala</p>
                <slot>
                    <p>lalala</p>
                </slot>
                <p>lalala</p>
            </template>

154.
    具名插槽
        指有name属性的插槽

155.
    作用域插槽
        在封装组件时，为预留的<slot>提供属性对应的值，这种用法，叫做“作用域插槽”,如<solt name="content" msg="hello"></solt>

        调用该组件插槽
        <template #content="scope">
            <p>{{scope}}</p> //结果为{msg:"hello"}
        </template>

160.
    自定义指令
        <h1 v-color>lala</h1>
        //私有自定义指令的节点
        directives:{
            //定义名为color的指令，指向一个配置对象
            color:{
                //当指令第一次被绑定到元素上的时候，会立即触发bind函数
                //形参中的e1表示当前指令所绑定到的那个DOM对象
                bind（el){
                    console.log('触发了v-color的bind函数')
                    el.style.color="red" //将绑定dom元素的字体颜色改为红色
                }
            }
        } 
        
161.
    binding.value
        <h1 v-color="color">lala</h1>
        export default{
            data(){
                return{
                    color:red
                }
            }
            //私有自定义指令的节点
            directives:{
                //定义名为color的指令，指向一个配置对象
                color:{
                    //当指令第一次被绑定到元素上的时候，会立即触发bind函数
                    //形参中的e1表示当前指令所绑定到的那个DOM对象
                    bind（el,bind){
                        console.log('触发了v-color的bind函数')
                        el.style.color=bind.value //将绑定dom元素的字体颜色改为红色
                    }
                }
            }
        }
        
162.
    update函数
        bind函数只调用1次：当指令第一次绑定到元素时调用，但是当DOM更新时bind函数不会被触发。
        update函数会在每次DOM更新时被调用。示例代码如下：
        
            directives:{
                color:{
                    bind(el,binding){
                        el.style.color=binding.value
                    },
                    update(el,binding){
                        el.style.color=binding.value
                    }
                }
            }

163.
    函数简写
        如果bind和update函数中的逻辑完全相同，则对象格式的自定义指令可以简写成函数格式：
            directives:{
                color(el,binding){
                    el.style.color=binding.value
                }
            }

164.
    全局自定义指令
        写在main.js中
            Vue.directive('color',function(el,binding){
                代码
            })

165.
    main.js中的Vue.config.productionTip = false用于提示开发者当前是在开发模式

166.
    ESLint
        用于统一代码风格

169.
    ESLint常见语法规则
        quotes
            默认：字符串需要使用单引号包裹
        key-spacing
            默认：对象的属性和值之间，需要有一个空格分割
        comma-dangle
            默认：对象或数组的末尾，不允许出现多余的逗号
        no-multiple-empty-lines
            不允许出现多个空行
        no-trailing-spaces
            不允许在行尾出现多余的空格
        eol-last
            默认：文件的末尾必须保留一个空行
        spaced-comment
            在注释中的/或/*后强制使用一致的间距
        indent
            强制一致的缩进
        import/first
            import导入模块的语句必须声明在文件的顶部
        space-before-function-paren
            方法的形参之前是否需要保留一个空格

170.
    ESLint插件（就叫ESLint）

173.
    在main.js全局配置axios
        import axios from "axios"
        import Vue from "vue"
        
        // 全局配置axios的请求根路径
        axios.defaults.baseURL="接口的根路径，如：http://www.liulongbin.top:3006"
        // 把axios挂载到Vue.prototype上，供每个vue组件直接使用
        Vue.prototype.$http=axios

175.
    什么是路由
        路由(英文：router)就是对应关系

    SPA与前端路由
        SPA指的是一个Wb网站只有唯一的一个HTML页面，所有组件的展示与切换都在这唯一的一个页面内完成。
        此时，不同组件之间的切换需要通过前端路由来实现。
        结论：在SPA项目中，不同功能之间的切换，要依赖于前端路由来完成！
    
    什么是前端路由
        通俗易懂的概念：Hash地址与组件之间的对应关系。

    锚链接不会造成页面刷新，但产生浏览器历史（可以用前进后退）

    使用锚链接之后url地址后面会产生#锚记名，这种地址叫做hash地址

176.
    前端路由的工作方式
        ①用户点击了页面上的路由链接
        ②导致了URL地址栏中的Hash值发生了变化
        ③前端路由监听了到Hash地址的变化
        ④前端路由把当前Hash地址对应的组件渲染都浏览器中

178.
    什么是vue-router
        Vue-router是vue.js官方给出的路由解决方案。它只能结合Vue项目进行使用，能够轻松的管理SPA项目中组件的切换。
        vue-router的官方文档地址：https://router..vuejs.org/zh/

    vue-router安装和配置的步骤
        1.安装vue-router包
        2.创建路由模块
        3.导入并挂载路由模块
        4.声明路由链接和占位符

    在vue2的项目中，安装vue-router的命令如下：
        npm i vue-router@3.5.2 -S

    创建路由模块
        在src源代码下，新建router/index.js路由模块，并初始化如下的代码：
            //导入两个包
            import Vue from "vue"
            import VueRouter from "vue-router"

            //调用Vue.use()函数，把VueRouter安装为Vue的插件
            Vue.use(VueRouter)

            //创建路由的实例对象
            const router = new VueRouter

            //向外共享路由的实例对象
            export default router

    导入路由模块
        import router from "@/router/index.js"

179.
    在进行模块化导入的时候，如果给定的是文件夹，则默认导入这个文件夹下，名字叫做index.js的文件

180.
    只要在项目中安装和配置了vue-router,就可以使用<router-view>这个组件了
    它的作用很单纯：就是占位符

    用法：
        1.在App.vue中放入占位符<router-view></router-view>
        2.在之前router中创建的index.js中进行hash配置
            import Home from 路径
            import Movie from 路径
            import About from 路径

            const router=new VueRouter({
                routes:[
                    //路由规则
                    {path:'/home',component:Home},
                    {path:'/movie',component:Movie},
                    {path:'/about',component:About}
                ]
            })

181.
    当安装和配置了vue-router后，就可以使用router-link来替代普通的a链接了，如下：
        <a href="#/home">首页</a> 可以改为
        <router-link to="/home">首页</router-link>

182.
    路径重定向
        路由重定向指的是：用户在访问地址A的时候，强制用户跳转到地址C,从而展示特定的组件页面。
        通过路由规则的redirect属性，指定一个新的路由地址，可以很方便地设置路由的重定向：
            const router=new VueRouter({
                routes:[
                    {path:'/',redirect:'home'}, //当用户访问/的时候，通过redirect属性跳转到/home对应的路由规则
                    {path:'/home',component:Home}
                ]
            })

183.
    嵌套路由
        通过路由来实现组件的嵌套展示，叫做嵌套路由
            ①模板内容中又有子级路由链接
            ②点击子级路由链接显示子级模板内容
    
    子路由的hash地址开头要重写一遍父元素的hash地址，如：
        about下的组件路由地址，就要写/about/hash地址

184.
    通过children属性在src/router/index.js中声明子路由的规则，如：
        const router =new VueRouter({
            routers:[
                {
                    path:'/about',
                    component:'About',
                    children:[
                        {path:'tab1',component:'Tab1'} //字组件尽量不要以斜线开头
                    ]
                }
            ]
        })

185.
    用了嵌套路由，别忘记子路由重定向

    子路由规则
        默认子路由：如果children数组中，某个路由规则的path值为空字符串，则这条路由规则，叫做“默认子路由”

186.
    动态路由匹配
        动态路由指的是：把Hash地址中可变的部分定义为参数项，从而提高路由规则的复用性。
        在vue-router中使用英文的冒号(：)来定义路由的参数项。示例代码如下：
            //路由中的动态参数以：进行声明，冒号后面的是动态参数的名称
            path:'/movie/:id',component:Movie
            
            //将以下3个路由规则，合并成了一个，提高了路由规则的复用性
            path:'/movie/1',component:Movie
            path:'/movie/2',component:Movie
            path:'/movie/3',component:Movie
    
    拿到组件动态参数的值：$route.params.mid

187.
    可以为路由规则开启props传参，从而方便地拿到动态参数的值
        // src/router/index.js
        const router=new VueRouter({
                routers:[
                    //路由规则
                    {path:'/movie/:mid',component:Movie,props:true}
                ]
            })

        // Movie组件

        export default {
            props:['mid']
        }

188.
    this.$route是路由的“参数对象”
    this.$router是路由的“导航对象”

    注意1：在hash地址中，/后面的参数项，叫做“路径参数”
        在路由“参数对象”中，需要使用 this.$route.params 来访问路径参数

    注意2：在hash地址中，?后面的参数项，叫做“查询参数”
        在路由“参数对象”中，需要使用 this.$route.query 来访问查询参数

    注意3：在this.$route中，path只是路径部分，fullPath是完整的地址，例如：
        /movie/2?name=zs&age=20是fullPath的值
        /movie/2是path的值

189.
    导航
        点击页面链接导致组件切换，叫做导航

    声明式导航&编程式导航
        在浏览器中，点击链接实现导航的方式，叫做声明式导航。例如：
            普通网页中点击<a>链接、vue项目中点击<router-link>都属于声明式导航

        在浏览器中，调用API方法实现导航的方式，叫做编程式导航。例如：
            普通网页中调用location.href跳转到新页面的方式，属于编程式导航

    vue-router 中的编程式导航API
        Vue-router提供了许多编程式导航的APl,其中最常用的导航API分别是：
            ①this.$router.push('hash地址')
                跳转到指定hash地址，并增加一条历史记录

            ②this.$router.replace('hash地址')
                跳转到指定的hash地址，并替换掉当前的历史记录

            ③this.$router.go(数值n)
                可以在浏览历史中进行前进和后退

                //go(-1) 表示后退一层
                //如果后退的层数超过上限，则原地不动
    
    $router.go的简化用法
        在实际开发中，一般只会前进和后退一层页面。因此Vue-router提供了如下两个便捷方法：
        ①$router.back()
            在历史记录中，后退到上一个页面
        ②$router.forward()
            在历史记录中，前进到下一个页面

        在行内使用编程式导航跳转的时候，this必须要省略，否则会报错

190.
    导航守卫
        导航守卫可以控制路由的访问权限

    全局前置守卫
        每次发生路由的导航跳转时，都会触发全局前置守卫。因此，在全局前置守卫中，程序员可以对每个路由进行访问权限的控制：

        // 创建路由的实例对象 
        const router=new VueRouter({...})

        // 调用路由实例对象的beforeEach方法，即可声明"全局前置守卫"
        // 每次发生路由导航跳转的时候，都会自动触发fn这个“回调函数”
        router.beforeEach((to,from,next)=>{})
            //to是将要访问的路由的信息对象
            //from是将要离开的路由的信息对象
            //next是一个函数，调用next()表示放行，允许这次路由导航（必须要有）

191.
    next函数的3种调用方式
        当前用户拥有后台主页的访问权限，直接放行：next（）
        当前用户没有后台主页的访问权限，强制其跳转到登录页面：next('/login')
        当前用户没有后台主页的访问权限，不允许跳转到后台主页：next(false)

204.
    路由相关的组件要放到与components同级的views文件夹中
   
228.
	什么是ES6模块化规范
		ES6模块化规范是浏览器端与服务器端通用的模块化开发规范。它的出现极大的降低了前端开发者的模块化学习成本，开发者不需再额外学习AMD、CMD或CommonJS等模块化规范。
		ES6模块化规范中定义：
			每个js文件都是一个独立的模块
			导入其它模块成员使用import关键字
			向外共享模块成员使用export关键字
			
229.
	在node.js中体验ES6模块化
		node.js中默认仅支持CommonJS模块化规范，若想基于node.js体验与学习ES6的模块化语法，可以按照
		如下两个步骤进行配置：
		①确保安装了v14.15.1或更高版本的node.js
		②在package.json的根节点中添加"type":"module"节点
		
230.
	ES6的模块化主要包含如下3种用法：
		①默认导出与默认导入
		②按需导出与按需导入
		③直接导入并执行模块中的代码
		
	默认导出：
		let n1 = 10
		let n2 = 20
		function show(){}
		
		export default{
			n1,show
		}
	默认导入：
		import 接收名称 from "模块标识符"
		
231.
	默认导出的注意事项
		每个模块中，只允许使用唯一的一次export default,否则会报错！（就是只能用一次export default）
		
232.
	按需导出
		语法：export 按需导出的成员，如：
			export let s1 = 'a'
			
			export let s2= 'c'
			
			export function say(){}
			
	按需导入
		语法：import {s1} from '模块标识符'，如：
			import {s1,s2} from './03.js'
			
233.
	按需导出与按需导入的注意事项
		1.每个模块中可以使用多次按需导出
		2.按需导入的成员名称必须和按需导出的名称保持一致
		3.按需导入时，可以使用as关键字进行重命名
		4.按需导入可以和默认导入一起使用
	
234.
	直接导入并执行模块中的代码
		如果只想单纯地执行某个模块中的代码，并不需要得到模块中向外共享的成员。此时，可以直接导入并执行模块代码，示例代码如下：
			for (let i =0 ; i < 3 ; i++){
				console.log(i)
			}
			-----------下面的是导入模块的文件------------
			import './05.js' //打印结果为0, 1, 2
			
236.
	Promise的基本概念
		①Promise是一个构造函数
			我们可以创建Promise的实例const p=new Promise（）
			new出来的Promise实例对象，代表一个异步操作
		②Promise.prototype上包含一个.then（）方法
			每一次new Promise（）构造函数得到的实例对象，
			都可以通过原型链的方式访问到.then（）方法，例如p.then（）
		③.then（）方法用来预先指定成功和失败的回调函数
			p.then(成功的回调函数，失败的回调函数)
			p.then(result =>{},error =>{})
			调用.then（）方法时，成功的回调函数是必选的、失败的回调函数是可选的
			
237.
	基于then-fs读取文件内容
		由于node.js官方提供的fs模块仅支持以回调函数的方式读取文件，不支持Promise的调用方式。因此，需
		要先运行如下的命令，安装then-fs这个第三方包，从而支持我们基于Promise的方式读取文件的内容：
			npm i then-fs
			
	then-fs的基本使用
		调用then-fs提供的readFile（）方法，可以异步地读取文件的内容，它的返回值是Promise的实例对象。因
		此可以调用。then（）方法为每个Promise异步操作指定成功和失败之后的回调函数。示例代码如下：
			import thenFs from 'then-fs'
			
			thenFs.readFile('./files/1.txt','utf-8').then(r1 => {console.log(r1)},err=>{console.log(err.message)})
			thenFs.readFile('./files/2.txt','utf-8').then(r2 => {console.log(r2)},err=>{console.log(err.message)})
			thenFs.readFile('./files/3.txt','utf-8').then(r3 => {console.log(r3)},err=>{console.log(err.message)})
			
		注意：上述代码无法保证文件的读取顺序，需要进一步改进（因为打印顺序随机）
		
238.
	.then()方法的特性
		如果上一个.then方法中返回了一个新的Promise实例对象，则可以通过下一个.then继续进行处理。通过.then()方法的链式调用，就解决了回调地狱的问题
			import thenFs from 'then-fs'
			
			thenFs.readFile('./files/1.txt','utf-8').then((r1)=>{
				console.log(r1)
				return thenFs.readFile('./files/2.txt','utf-8')
			})
            .then(r2=>{
                console.log(r2)
                return thenFs.readFile('./files/3.txt','utf-8')
            })
            .then(r3=>{
                console.log(r3)
            })

239.
    通过.catch捕获错误
        在Promise的链式操作中如果发生了错误，可以使用Promise.prototype.catch方法进行捕获和处理：
            thenFs.readFile('./files/1.txt','utf-8').then((r1)=>{
				console.log(r1)
				return thenFs.readFile('./files/2.txt','utf-8')
			})
            .then(r2=>{
                console.log(r2)
                return thenFs.readFile('./files/3.txt','utf-8')
            })
            .then(r3=>{
                console.log(r3)
            })
            .catch(err=>{
                console.log(err.  message)
            })

        当catch捕获到错误之后后面的代码便不会执行，若想让后面的代码继续执行，则可以将.catch()方法移动到第一个.then的前面

240.
    Promise.all()方法
        Promise.all（）方法会发起并行的Promise异步操作，等所有的异步操作全部结束后才会执行下一步的.then操作（等待机制）。示例代码如下：
            const promiseArr = [
                thisFs.readFile('./files/1.txt','utf-8')
                thisFs.readFile('./files/2.txt','utf-8')
                thisFs.readFile('./files/3.txt','utf-8')
            ]

            Promise.all(promiseArr).then(result => {
                console.log(result)
            })  //结果为[111,222,333]

    Promise.race()方法
        Promise.race（）方法会发起并行的Promise异步操作，只要任何一个异步操作完成，就立即执行下一步的then操作（赛跑机制）。示例代码如下：
            const promiseArr = [
                thisFs.readFile('./files/1.txt','utf-8')
                thisFs.readFile('./files/2.txt','utf-8')
                thisFs.readFile('./files/3.txt','utf-8')
            ]

            Promise.race(promiseArr).then(result => {
                console.log(result)
            })  //结果为随机一个数

242.
    听不懂

243.
    什么是async/await
        async./await是ES8(ECMAScript2017)引入的新语法，用来简化Promise异步操作。在async./await出
        现之前，开发者只能通过链式.then（）的方式处理Promise异步操作。
            .then链式调用的优点：解决了回调地狱的问题
            .then链式调用的缺点：代码冗余、阅读性差、不易理解
    
    async function getAllFile(){
        const r1 = await thenFs.readFile('1.txt','utf-8') //用await直接可以拿到Promise对象的结果，那外面的function要用async修饰
        console.log(r1)
    }

244.
    async/await的使用注意事项
        ①如果在function中使用了await,则function必须被async修饰
        ②在async方法中，第一个await之前的代码会同步执行，await之后的代码会异步执行

245.
    为了防止某个耗时任务导致程序假死的问题，JavaScript把待执行的任务分为了两类：
        ①同步任务(synchronous)
            又叫做非耗时任务，指的是在主线程上排队执行的那些任务
            只有前一个任务执行完毕，才能执行后一个任务
        ②异步任务(asynchronous)
            又叫做耗时任务，异步任务由JavaScript委托给宿主环境进行执行
            当异步任务执行完成后，会通知JavaScript主线程执行异步任务的回调函数

246.
    同步任务和异步任务的执行过程
        1.同步任务由JavaScript主线程次序执行
        2.异步任务委托给宿主环境执行
        3.已完成的异步任务对应的回调函数，会被加入到任务队列中等待执行
        4.JavaScript主线程的执行栈被清空后，会读取任务队列中的回调函数，次序执行
        5.JavaScript主线程不断重复上面的第4步

247.
    EventLoop的基本概念
        JavaScript主线程从"任务队列”中读取异步任务的回调函数，放到执行栈中依次执行。这个过程是循环不断的，所以整个的这种运行机制又称为EventLoop（事件循环）。

248.
    什么是宏任务和微任务
        宏任务
            异步Ajax请求
            setTimeout，setInterval
            文件操作
            其他宏任务
        
        微任务
            Promise.then、.catch和.finally
            process.nextTick
            其他微任务

    宏任务和微任务的执行顺序
        每一个宏任务执行完之后，都会检查是否存在待执行的微任务，
        如果有，则执行完所有微任务之后，再继续执行下一个宏任务。

344.
    组件注册时名称的大小写
        在进行组件的注册时，定义组件注册名称的方式有两种：
            ①使用kebab-case命名法(俗称短横线命名法，例如my-swiper和my-search)
            ②使用PascalCase命名法(俗称帕斯卡命名法或大驼峰命名法，例如MySwiper和MySearch)

        短横线命名法的特点：
            必须严格按照短横线名称进行使用

        帕斯卡命名法的特点：
            既可以严格按照帕斯卡名称进行使用，又可以转化为短横线名称进行使用（如MySwiper可以写成my-swiper）

    注意：在实际开发中，推荐使用帕斯卡命名法为组件注册名称，因为它的适用性更强。

363.
    props的多种类型
        如果某个prop属性值的类型不唯一，此时可以通过数组的形式，为其指定多个可能的类型，实例代码如下：
            props:{
                propA:[String , Number]
            }


373.
    自定义事件的3个使用步骤
        在封装组件时：
            1.声明自定义事件
                export default{
                    emits:['change']
                }
            2.触发自定义事件
                <button @click="onBtnClick"></button>

                export default{
                    emits:['change'],

                    methods:{
                        onBtnClick(){
                            this.$emit('change')
                        }
                    }
                }

        在使用组件时：
            3.监听自定义事件
                <my-counter @change="getCount"></my-counter>

375.
    自定义事件传参
        在调用this.$emit方法触发自定义事件时，可以通过第2个参数为自定义事件传参，示例代码如下：
            this.$emit('change',this.cout)

378.
    回头看

389.
    案例看到这里

403.
    侦听对象单个属性值的变化
        watch:{
            'info.username':{
                函数体
            }
        }

404.
    计算属性VS侦听器
        计算属性和侦听器侧重的应用场景不同：
            计算属性侧重于监听多个值的变化，最终计算并返回一个新值
            侦听器侧重于监听单个数据的变化，最终执行特定的业务处理，不需要有任何返回值

406.
    vue2的销毁生命周期函数名从 destroyed 改成了 unmounted

407.
    当组件重新渲染完毕之后会调用 updated 生命周期函数

414.
    vue3中，兄弟之间实现数据共享的方案是eventBus。可以借助第三包mitt来创建eventBus对象，从而实现兄弟之间的数据共享

        安装 mitt: npm i mitt

        1.先在 eventBus.js 中实例一个bus对象并导出
            import mitt from 'mitt'

            const bus = new mitt()

            export default bus

        2.在接收方自定义事件
            improt bus from '路径'

            export default {
                data(){
                    return{
                        count : 0
                    }
                },
                
                created(){
                    bus.on('countChange',count=>{
                        this.count = count
                    })
                }
            }

        3.在数据发送方触发事件
            improt bus from '路径'

            export default {
                data(){
                    return{
                        count : 0
                    }
                },
                
                methods:{
                    addCount(){
                        this.count++
                        bus.emit('countChange',this.count)
                    }
                }
            }

416.
    后代关系组件之间的数据共享
        后代关系组件之间共享数据，指的是父节点的组件向其子孙组件共享数据。此时组件之间的嵌套关系比较复杂，
        可以使用provide和inject实现后代关系组件之间的数据共享。

        //父组件
        export default{
            data(){
                return{
                    color:red,
                    count:0
                }
            },
            provide(){
                return {
                    color:this.color
                    count:this.count
                }
            }
        }

        //孙组件
        <h5>{{color}}</h5>

        export default{
            inject : ['color','count']
        }
        
417.
    Vuex是终极的组件之间的数据共享方案。在企业级的Vue项目开发中，VueX可以让组件之间的数据共享变得高效、清晰、且易于维护。
        就比如父传子需要用到数据绑定，而子传父要用到自定义事件。。。。。。用vuex就可以统一传参

421.
    全局配置axios
        import axios from 'axios'
        
        const app = createApp(App)

        axios.default.baseURL = 'http://www.escook.com'

        app.config.globalProperties.$http = axios

460.
    可以回来看下，讲作用域插槽应用的

463.
    自定义指令
        <h1 v-color>lala</h1>
        //私有自定义指令的节点
        directives:{
            //定义名为color的指令，指向一个配置对象
            color:{
                //当绑定的元素渲染到DOM的时候，会立即触发mounted函数（vue2为bind）
                //形参中的el表示当前指令所绑定到的那个DOM对象
                mounted（el){
                    console.log('触发了v-color的bind函数')
                    el.style.color="red" //将绑定dom元素的字体颜色改为红色
                }
            }
        } 

464.   
    声明全局自定义指令语法
    //main.js中
        const app = Vue.createApp({})
        app.directive('focus',{
            //当被绑定的元素插入到DOM中，自动触发mounted
            mounted(el){
                el.focus()
            }
        })
    
465.
    vue2自定义指令中的update在vue3中被改成了updated

466.
    updated 函数
        mounted函数只在元素第一次插入DOM时被调用，当DOM更新时mounted函数不会被触发。
        updated函数会在每次DOM更新完成后被调用。

        注意：注意：在vue2的项目中使用自定义指令时，[mounted->bind][updated->update]

467.
    指令的参数值
        在绑定指令时，可以通过“等号”的形式为指令绑定具体的参数值，示例代码如下：
            <input type="text" v-color="'red'">

            app.directive('color',(el,binding)=>{
                el.style.color=binding.value
            })

482.
    后端路由
        后端路由指的是：请求方式、请求地址与function处理函数之间的对应关系。在node,js课程中，express
        路由的基本用法如下：
            cosnt express = require('express')
            const router = express.Router()

            router.get('/userlist',function(req,res){ /*路由处理函数*/ })
            router.post('/adduser',function(req,res){ /*路由处理函数*/ })

            module.exports = router

484.
    在created生命周期函数中监听浏览器地址栏中Hash地址的变化，动态切换要展示的组件的名称：
        created(){
            window.onhashchange= () =>{
                switch(localhost.hash){
                    case '#/home':
                        this.comName = 'my-home'
                        break
                    case '#/movie'
                        this.comName = 'my-movie'
                        break
                }
            }
        }

485.
    Vue-router的版本
        vue-router目前有3.X的版本和4.X的版本。其中：
            vue-router3.X只能结合Vue2进行使用
            Vue-router4.x只能结合Vue3进行使用

486.
    vue-router4.x的基本使用步骤
        1.在项目中安装vue-router
        2.定义路由组件
        3.声明路由链接和占位符
        4.创建路由模块
        5.导入并挂载路由模块

    安装 vue-router 
        npm i vue-router@next -S

487.    
    vue3创建路由模块
        在项目中创建router.js路由模块，在其中按照如下4个步骤创建并得到路由的实例对象：
            ①从Vue-router中按需导入两个方法
                // createRouter 用于创建路由的实例对象
                // createWebHashHistory 用于指定路由的工作模式
                import {createRouter,createWebHashHistory} from 'vue-router'
            ②导入需要使用路由控制的组件
            ③创建路由实例对象
                const router =createRouter({
                    history:createWebHashHistory()
                    routes:[
                        {path:'/home',component:Home}
                    ]
                })
            ④向外共享路由实例对象
            ⑤在main,js中导入并挂载路由模块

489.
    路由高亮
        可以通过如下的两种方式，将激活的路由链接进行高亮显示：
            1.使用默认的高亮class类
            2.自定义路由高亮的class类
        
    默认的高亮class类
        被激活的路由链接，默认会应用一个叫做router-link-active的类名。开发者可以使用此类名选择器，为激活的路由链接设置高亮的样式：
            .router-link-active{
                backgroundcolor:red;
                color:white;
                font-weight:bold
            }

    自定义路由高亮的class类
        在创建路由的实例对象时，开发者可以基于linkActiveClass属性，自定义路由链接被激活时所应用的类名：
            const router = createRouter({
                history:createWebHashHistory(),
                linkActiveClass:'自定义名字'    //这里改
            })

492.
    嵌套路由重定向
        在父组件中加入redirect:'/about/tab1'（这是重定向的路由地址）

494.
    $route.params参数对象
        通过动态路由匹配的方式渲染出来的组件中，可以使用$route.params对象访问到动态匹配的参数值。如下：
            <h3>MyMovie组件 {{$router.params.id}}</h3>

    使用props接收路由参数
        为了简化路由参数的获取形式，vue-router允许在路由规则中开启props传参。示例代码如下：
            //router.js
            {path: '/movie/:id',component:Movie,props:true}

            //组件
            <h3>MyMovie组件 {{id}}</h3>

            props:['id']

496.
    命名路由
        通过name属性为路由规则定义名称的方式，叫做命名路由。实例代码如下：
            {
                path:'/movie/:id',
                name:'mov',
                component:Movie,
                props:true
            }

            注意：命名路由的name值不能重复，必须保证唯一性

    使用命名路由实现声明式导航
        为<router-link>标签动态绑定to属性的值，并通过name属性指定要跳转到的路由规则。期间还可以用
        params属性指定跳转期间要携带的路由参数。示例代码如下：
            <router-link :to='{name:'mov',params:{ id:3 }}'></router-link>

516.
    vue-cli提供的两种创建项目的方式
        基于【命令行】的方式创建vue项目
            vue create 项目名称

        基于【可视化面板】创建vue项目
            vue ui（使用时记得不要把终端关掉，不然可视化面板也不会正常工作了）
    
519.
    回来看看

522.
    什么是vue组件库
        在实际开发中，前端开发者可以把自己封装的，Vue组件整理、打包、并发布为npm的包，从而供其他人下载
        和使用。这种可以直接下载并在项目中使用的现成组件，就叫做Vue组件库。

    vue组件库和bootstrap的区别
        二者之间存在本质的区别：
        ●bootstrap只提供了纯粹的原材料(css样式、HTML结构以及JS特效)，需要由开发者做进一步的组装和改造
        ●Vue组件库是遵循Vue语法、高度定制的现成组件，开箱即用

    最常用的Vue组件库
        ①PC端
            lement Ul (https://element.eleme.cn/#/zh-CN)
            View Ul (http://v1.iviewui.com/)
        ②
        移动端
            Mint Ul (http://mint-ui.github.io/#!/zh-cn)
            Vant (https://vant-contrib.gitee.io/vant/#/zh-CN/)

523.
    Element UI
        Element Ul是饿了么前端团队开源的一套PC端vue组件库。支持在vue2和vue3的项目中使用：
            vue2的项目使用旧版的Element Ul(https://element.eleme.cn/#/zh-CN)
            vue3的项目使用新版的Element Plus(https://element-plus.gitee.io/#/zh-CN)

        在vue2的项目中安装 element-ui
            npm i element-ui -S

        开发者可以一次性完整引入所有的element-ui组件，或是根据需求，只按需引入用到的element-ui组件：
            完整引入：操作简单，但是会额外引入一些用不到的组件，导致项目体积过大
            按需引入：操作相对复杂一些，但是只会引入用到的组件，能起到优化项目体积的目的

        完整引入：
            import Vue from 'vue'
            import ElementUI from 'element-ui'
            // 引入 element ui 组件样式
            import 'element-ui/lib/theme-chalk/index.css'

            Vue.use(ElementUI)

524.
    element-ui按需引入
        借助babel-plugin-component,我们可以只引入需要的组件，以达到减小项目体积的目的。

            步骤1，安装babel-plugin-component:
                npm i babel-plugin-compoent -D
            
            步骤2，修改根目录下的babel.config,js配置文件，新增plugins节点如下：
                module.export = {
                    plugins:{
                        [
                            'compoent',
                            {
                                libraryName:'element-ui',
                                styleLibraryName:'theme-chalk'
                            }
                        ]
                    }
                }

            步骤3，如果你只希望引入部分组件，比如Button,那么需要在main,js中写入以下内容：
                import { Button } from 'element-ui'
                Vue.compoent( Button.name , Button ) //或简写为Vue.use(Button)

525.
    把组件的导入和注册封装为独立的模块
        在src目录下新建element-ui/index.js模块，并声明如下的代码：

            import Vue from 'vue'
            import { Button,Input } from 'element-ui'

            Vue.use(Button)
            Vue.use(Input)

            // 在main.js中导入
            import './element-ui'

527.
    什么是拦截器
        拦截器(英文：Interceptors)会在每次发起ajax请求和得到响应的时候自动被触发。

528.
    配置请求拦截器
        通过axios.interceptors.request.use(成功的回调，失败的回调)可以配置请求拦截器。示例代码如下：
            axios.interceptors.request.use(function(config){
                return config
            },function(error){
                return Promise.reject(error)
            })
        注意：失败的回调函数可以被省略

529.
    回来把拦截器的内容都看一下